# Webhook Inbox Processor - Implementation Plan

## ðŸŽ¯ Overview
Implement the missing "Stage 2 Processor" that reads from `webhook_inbox_bannos/flourlane`, extracts order data using Liquid template logic, and populates `orders_bannos/flourlane` tables with clean, structured data.

## ðŸ“Š Current Architecture

**What's Working:**
```
Shopify â†’ Edge Function â†’ webhook_inbox (raw JSON saved) âœ…
```

**What's Missing:**
```
webhook_inbox (unprocessed) â†’ [PROCESSOR] â†’ orders_bannos/flourlane âŒ
                                   â†‘
                           THIS IS MISSING!
```

## ðŸ” Data Available in webhook_inbox.payload

From the sample row `bannos-24517`:

**Order Info:**
- `name`: "#B24517"
- `order_number`: 24517
- `currency`: "AUD"
- `total_price`: "125.00"

**Customer Info:**
- `customer.first_name`: "Lauren"
- `customer.last_name`: "Aliferis"  
- `customer.email`: "lauren.aliferis101@gmail.com"
- `shipping_address.name`: "Lauren Aliferis" (or use customer name as fallback)

**Product Info (line_items[0]):**
- `title`: "White Personalised Cake"
- `variant_title`: "Medium / Vanilla"
- `quantity`: 1
- `properties[]`: Array of custom fields (Cake Writing, etc.)

**Delivery Info (note_attributes):**
- "Delivery Method" â†’ "Local delivery" or "Pickup"
- "Local Delivery Date and Time" â†’ "Sat 8 Nov 2025 between 8:00 AM and 6:00 PM"

## ðŸŽ¯ What We Need to Extract

Map to `orders_bannos` / `orders_flourlane` columns:

| Database Column | Source from Payload |
|----------------|---------------------|
| `human_id` | Generated by trigger (bannos-{order_number}) |
| `shopify_order_number` | `order_number` (24517) |
| `customer_name` | `shipping_address.name` or `customer.first_name + last_name` |
| `product_title` | `line_items[0].title` |
| `size` | Extract from `variant_title` or properties |
| `flavour` | Extract from `variant_title` or properties |
| `item_qty` | `line_items[0].quantity` |
| `due_date` | Parse from "Local Delivery Date and Time" note_attribute |
| `delivery_method` | "Delivery Method" note_attribute |
| `notes` | `order.note` |
| `currency` | `currency` |
| `total_amount` | `total_price` |

## ðŸ”§ Implementation Options

### Option A: JavaScript Extraction (Recommended for MVP)

**Pros:**
- No Liquid library needed
- Faster execution
- Easier to debug
- Direct JSON access

**Cons:**
- Have to manually replicate Liquid logic
- More code to write

**Code Example:**
```typescript
const payload = inboxRow.payload;

const extractedData = {
  shopify_order_number: payload.order_number,
  customer_name: payload.shipping_address?.name || 
                 `${payload.customer?.first_name} ${payload.customer?.last_name}`,
  product_title: payload.line_items[0]?.title,
  // ... etc
};
```

### Option B: LiquidJS Library

**Pros:**
- Reuse existing Liquid template (modified for JSON output)
- Handles complex logic automatically

**Cons:**
- Need to install liquidjs library
- Slower performance
- Template must be modified to output JSON instead of HTML

**Code Example:**
```typescript
import { Liquid } from 'liquidjs';
const engine = new Liquid();
const template = `...liquid template...`;
const result = await engine.parseAndRender(template, { order: payload });
```

## ðŸ“‹ Recommended Architecture

### **Hybrid Approach** (Best of both worlds):

1. **Edge Function: `process-webhook-inbox`**
   - Triggered: Manually via button OR scheduled cron
   - Reads: Unprocessed rows from webhook_inbox_bannos/flourlane
   - Extracts: Data using JavaScript (following your Liquid template logic)
   - Writes: To orders_bannos/flourlane via RPC
   - Marks: Row as `processed = true`

2. **Database RPC: `process_inbox_order`**
   - Called by Edge Function for each order
   - Validates data
   - Inserts into orders table
   - Returns success/error

## ðŸ› ï¸ Implementation Steps

### Phase 1: Create Processing RPC
- File: `supabase/migrations/067_process_inbox_rpc.sql`
- Function: `process_inbox_order(p_store, p_payload jsonb)`
- Extracts fields from JSON
- Inserts to orders_bannos or orders_flourlane
- Returns success/error

### Phase 2: Create Edge Function
- File: `supabase/functions/process-webhook-inbox/index.ts`
- Reads unprocessed inbox rows (LIMIT 10 per run)
- Calls `process_inbox_order` RPC for each
- Marks rows as processed
- Returns count of processed/failed

### Phase 3: Add UI Trigger (Settings Page)
- Add "Process Inbox" button in Bannos/Flourlane Settings
- Shows count of unprocessed orders
- Triggers Edge Function
- Displays progress/results

### Phase 4: Schedule Auto-Processing (Future)
- Supabase Edge Function Cron
- Runs every 5 minutes
- Processes any unprocessed inbox rows

## ðŸ” Fields to Extract

Based on your Liquid template + payload:

```typescript
{
  // From top level
  shopify_order_number: payload.order_number,
  shopify_order_id: payload.id,
  currency: payload.currency,
  total_amount: parseFloat(payload.total_price),
  
  // Customer (with fallback)
  customer_name: payload.shipping_address?.name || 
                 `${payload.customer.first_name} ${payload.customer.last_name}`.trim(),
  
  // From first line item
  product_title: payload.line_items[0].title,
  item_qty: payload.line_items[0].quantity,
  
  // Parse from variant_title "Medium / Vanilla"
  size: extractSize(payload.line_items[0].variant_title), // "Medium"
  flavour: extractFlavour(payload.line_items[0].variant_title), // "Vanilla"
  
  // From note_attributes
  due_date: parseDueDate(findNoteAttribute('Local Delivery Date and Time')),
  delivery_method: findNoteAttribute('Delivery Method'), // "pickup" or "delivery"
  
  // Notes
  notes: payload.note || null
}
```

## â“ Questions Before Building

1. **Multi-cake orders:** If `line_items.length > 1`, should we:
   - a) Create multiple order records (one per cake)
   - b) Only process first line_item
   - c) Combine into one order

2. **Properties extraction:** Line items have custom properties (Cake Writing, etc.). Should these:
   - a) Go into `notes` field (JSON or text)
   - b) Have dedicated columns
   - c) Be ignored for now

3. **Date parsing:** "Sat 8 Nov 2025 between 8:00 AM and 6:00 PM"
   - Need to parse to `YYYY-MM-DD` format
   - Should we also store the time range?

4. **Testing strategy:**
   - Process the existing `bannos-24517` order as first test
   - Verify it appears correctly in UI
   - Then process all unprocessed orders

Let me know your answers and I'll create the detailed implementation!

