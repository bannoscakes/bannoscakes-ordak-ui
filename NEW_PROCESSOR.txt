// Paste your new Processor code here
// Order Processor - Processes Shopify webhooks and populates orders tables
// Reads from: webhooks_inbox
// Outputs to: orders_table_bannos, orders_table_flourlane

import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

// ============================================================================
// CONFIGURATION
// ============================================================================

const supabaseUrl = Deno.env.get('SUPABASE_URL')
const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')
const shopifyAdminTokenBannos = Deno.env.get('SHOPIFY_ADMIN_TOKEN')
const shopifyAdminTokenFlourlane = Deno.env.get('SHOPIFY_ADMIN_TOKEN_FLOURLANE')

const supabase = createClient(supabaseUrl, supabaseServiceKey)

// ============================================================================
// ITEM CATEGORIZATION (FROM LOVABLE)
// ============================================================================

function isCakeItem(item) {
  const title = (item.title || '').toLowerCase()
  
  // If it's an accessory, it's NOT a cake (priority rule)
  if (isAccessoryItem(item)) {
    return false
  }
  
  // Contains "cake" but exclude accessory patterns
  if (title.includes('cake')) {
    if (title.includes('topper') || title.includes('decoration') || title.includes('pick')) {
      return false
    }
    return true
  }
  
  return false
}

function isAccessoryItem(item) {
  const title = (item.title || '').toLowerCase()
  return title.includes('candle') || title.includes('balloon') || title.includes('topper')
}

// ============================================================================
// LIQUID TEMPLATE EXTRACTION LOGIC - EXACT REPLICA
// ============================================================================

function extractCustomerName(shopifyOrder) {
  // Liquid: {% assign customer_name = order.shipping_address.name %}
  // {% if customer_name == blank %}{% assign customer_name = order.customer.name %}{% endif %}
  let customerName = shopifyOrder.shipping_address?.name
  if (!customerName || customerName.trim() === '') {
    customerName = shopifyOrder.customer?.name || 
                   `${shopifyOrder.customer?.first_name || ''} ${shopifyOrder.customer?.last_name || ''}`.trim()
  }
  return customerName || 'Customer'
}

function extractDeliveryDate(shopifyOrder) {
  // Liquid: {% assign delivery_date = order.attributes['Local Delivery Date and Time'] | split: 'between' | first | strip %}
  const noteAttributes = shopifyOrder.note_attributes || []
  
  const deliveryDateAttr = noteAttributes.find(attr => 
    attr.name === 'Local Delivery Date and Time'
  )
  
  if (deliveryDateAttr && deliveryDateAttr.value) {
    const dateText = deliveryDateAttr.value
    const datePart = dateText.split(' between ')[0].trim()
    
    try {
      const parsedDate = new Date(datePart)
      if (!isNaN(parsedDate.getTime())) {
        return parsedDate.toISOString().split('T')[0] // Return YYYY-MM-DD for database
      }
    } catch (error) {
      console.error('Failed to parse delivery date:', error)
    }
  }
  
  return null
}

function extractDeliveryMethod(shopifyOrder) {
  // Liquid: {% assign delivery_method = order.attributes['Delivery Method'] | downcase %}
  // {% if delivery_method contains 'pickup' or delivery_method contains 'pick up' %}
  const noteAttributes = shopifyOrder.note_attributes || []
  
  const deliveryMethodAttr = noteAttributes.find(attr => 
    attr.name === 'Delivery Method'
  )
  
  if (deliveryMethodAttr && deliveryMethodAttr.value) {
    const methodValue = deliveryMethodAttr.value.toLowerCase()
    if (methodValue.includes('pick up') || methodValue.includes('pickup')) {
      return 'Pickup'
    } else if (methodValue.includes('delivery')) {
      return 'Delivery'
    }
  }
  
  // Fallback: check shipping_address
  return shopifyOrder.shipping_address ? 'Delivery' : 'Pickup'
}

function extractAllProperties(item) {
  // Liquid template logic - EXACTLY as written:
  // {% for property in line_item.properties %}
  //   {% unless property.first contains "_origin" or property.first contains "_raw" 
  //      or property.first contains "gwp" or property.first contains "_LocalDeliveryID" %}
  //     {% if property.last != blank %}
  //       {{ property.first }}: {{ property.last }}
  //     {% endif %}
  //   {% endunless %}
  // {% endfor %}
  
  const properties = item.properties || []
  const extracted = []
  
  for (const prop of properties) {
    const name = (prop.name || '').toString()
    const value = (prop.value || '').toString()
    
    // Skip if name is blank
    if (!name) continue
    
    // UNLESS conditions - skip these
    if (name.includes('_origin')) continue
    if (name.includes('_raw')) continue
    if (name.includes('gwp')) continue
    if (name.includes('_LocalDeliveryID')) continue
    if (name.startsWith('_')) continue // Covers _mws_* and other _prefixed
    
    // IF property.last != blank
    if (value.trim() !== '') {
      extracted.push({
        name: name,
        value: value,
        display: `${name}: ${value}`
      })
    }
  }
  
  return extracted
}

function extractFlavour(item) {
  // Get all non-filtered properties and join them
  const properties = extractAllProperties(item)
  
  if (properties.length === 0) {
    return null
  }
  
  // Join with " | " separator
  return properties.map(p => p.display).join(' | ')
}

function extractSize(item) {
  // Extract size from variant_title
  // Liquid shows: {% if line_item.variant_title != blank %}{{ line_item.variant_title }}{% endif %}
  
  if (!item.variant_title) {
    return null
  }
  
  const variantTitle = item.variant_title
  
  // Parse out size from variant_title
  // Examples: "Small", "Medium #MWS Options 1", "Large Tall"
  
  // Check for compound sizes first
  if (variantTitle.toLowerCase().includes('gift size')) return 'Gift Size'
  if (variantTitle.toLowerCase().includes('small tall')) return 'Small Tall'
  if (variantTitle.toLowerCase().includes('medium tall')) return 'Medium Tall'
  if (variantTitle.toLowerCase().includes('large tall')) return 'Large Tall'
  
  // Check for basic sizes (before any #MWS or other suffixes)
  const sizePart = variantTitle.split('#')[0].trim()
  
  if (sizePart.toLowerCase().includes('small')) return 'Small'
  if (sizePart.toLowerCase().includes('medium')) return 'Medium'
  if (sizePart.toLowerCase().includes('large')) return 'Large'
  if (sizePart.toLowerCase().includes('tall')) return 'Tall'
  
  // Return the cleaned variant title if no standard size found
  return sizePart || variantTitle
}

function extractNotes(shopifyOrder) {
  // Liquid: {% if order.note != blank %}{{ order.note }}{% endif %}
  // {% if delivery_method.instructions != blank %}{{ delivery_method.instructions }}{% endif %}
  
  let notes = shopifyOrder.note || ''
  
  // Note: delivery_method.instructions doesn't exist in webhook JSON
  // It's part of the shipping_lines but not directly accessible
  // The Liquid template might be using a Shopify object that's not in webhook
  
  return notes.trim() || null
}

// ============================================================================
// ADMIN API - IMAGE FETCHING
// ============================================================================

async function fetchProductImage(productId, storeSource) {
  const adminToken = storeSource === 'Flourlane' 
    ? shopifyAdminTokenFlourlane
    : shopifyAdminTokenBannos
  
  const storeDomain = storeSource === 'Flourlane'
    ? 'flour-lane.myshopify.com'
    : 'bannos.myshopify.com'
  
  if (!adminToken) {
    console.error(`Admin token not found for ${storeSource}`)
    return null
  }
  
  const shopifyProductId = `gid://shopify/Product/${productId}`
  
  const query = `
    query getProductImages($id: ID!) {
      product(id: $id) {
        images(first: 1) {
          edges {
            node {
              originalSrc
            }
          }
        }
      }
    }
  `
  
  try {
    const response = await fetch(`https://${storeDomain}/admin/api/2025-01/graphql.json`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Shopify-Access-Token': adminToken,
      },
      body: JSON.stringify({
        query,
        variables: { id: shopifyProductId }
      }),
    })
    
    if (response.ok) {
      const data = await response.json()
      const images = data.data?.product?.images?.edges || []
      if (images.length > 0) {
        return images[0].node.originalSrc
      }
    }
  } catch (error) {
    console.error('Failed to fetch image from Admin API:', error)
  }
  
  return null
}

// ============================================================================
// ORDER SPLITTING LOGIC (FROM LOVABLE)
// ============================================================================

async function processOrderItems(shopifyOrder, storeSource) {
  const lineItems = shopifyOrder.line_items || []
  const cakeItems = []
  const accessoryItems = []
  
  // Categorize items
  for (const item of lineItems) {
    if (isCakeItem(item)) {
      // Add each cake as separate item (respecting quantity)
      for (let i = 0; i < item.quantity; i++) {
        cakeItems.push(item)
      }
    } else if (isAccessoryItem(item)) {
      accessoryItems.push(item)
    }
  }
  
  console.log(`Categorized: ${cakeItems.length} cakes, ${accessoryItems.length} accessories`)
  
  // Create accessories array for database
  const accessoriesForDB = accessoryItems.map(item => ({
    title: item.title,
    quantity: item.quantity,
    shopify_variant_id: item.variant_id?.toString(),
    shopify_product_id: item.product_id?.toString(),
    price: item.price,
    vendor: item.vendor
  }))
  
  // Extract common order data using Liquid template logic
  const customerName = extractCustomerName(shopifyOrder)
  const deliveryDate = extractDeliveryDate(shopifyOrder)
  const deliveryMethod = extractDeliveryMethod(shopifyOrder)
  const notes = extractNotes(shopifyOrder)
  
  const orders = []
  
  // If only one cake or no cakes, create single order
  if (cakeItems.length <= 1) {
    const cakeItem = cakeItems[0]
    
    const humanId = storeSource === 'Flourlane' 
      ? `flourlane-${shopifyOrder.order_number}`
      : `bannos-${shopifyOrder.order_number}`
    
    // Fetch product image from Admin API
    const productImage = cakeItem && cakeItem.product_id
      ? await fetchProductImage(cakeItem.product_id, storeSource)
      : null
    
    const order = {
      id: humanId,
      human_id: humanId,
      shopify_order_id: shopifyOrder.id?.toString(),
      shopify_order_gid: shopifyOrder.admin_graphql_api_id,
      shopify_order_number: shopifyOrder.order_number,
      customer_name: customerName,
      product_title: cakeItem ? cakeItem.title : 'Custom Order',
      flavour: cakeItem ? extractFlavour(cakeItem) : null,
      size: cakeItem ? extractSize(cakeItem) : null,
      item_qty: cakeItem ? cakeItem.quantity : 1,
      notes: notes,
      currency: shopifyOrder.currency || 'AUD',
      total_amount: parseFloat(shopifyOrder.total_price || 0),
      order_json: shopifyOrder,
      due_date: deliveryDate,
      delivery_method: deliveryMethod,
      product_image: productImage
    }
    
    // Add accessories only if they exist
    if (accessoriesForDB.length > 0) {
      order.accessories = accessoriesForDB
    }
    
    orders.push(order)
    
  } else {
    // Multiple cakes - split into separate orders
    const suffixes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']
    
    for (let i = 0; i < cakeItems.length; i++) {
      const cakeItem = cakeItems[i]
      const suffix = suffixes[i] || (i + 1).toString()
      const isFirstOrder = i === 0
      
      const humanId = storeSource === 'Flourlane'
        ? `flourlane-${shopifyOrder.order_number}-${suffix}`
        : `bannos-${shopifyOrder.order_number}-${suffix}`
      
      // Fetch product image from Admin API
      const productImage = cakeItem.product_id
        ? await fetchProductImage(cakeItem.product_id, storeSource)
        : null
      
      const order = {
        id: humanId,
        human_id: humanId,
        shopify_order_id: shopifyOrder.id?.toString(),
        shopify_order_gid: shopifyOrder.admin_graphql_api_id,
        shopify_order_number: shopifyOrder.order_number,
        customer_name: customerName,
        product_title: cakeItem.title,
        flavour: extractFlavour(cakeItem),
        size: extractSize(cakeItem),
        item_qty: 1,
        notes: notes,
        currency: shopifyOrder.currency || 'AUD',
        total_amount: parseFloat(shopifyOrder.total_price || 0),
        order_json: shopifyOrder,
        due_date: deliveryDate,
        delivery_method: deliveryMethod,
        product_image: productImage
      }
      
      // Accessories ONLY on first order (KEY RULE from Lovable)
      if (isFirstOrder && accessoriesForDB.length > 0) {
        order.accessories = accessoriesForDB
      }
      
      orders.push(order)
    }
  }
  
  return orders
}

// ============================================================================
// MAIN PROCESSOR
// ============================================================================

export async function processWebhook(webhookId) {
  try {
    console.log(`Processing webhook: ${webhookId}`)
    
    // Read webhook from webhooks_inbox
    const { data: webhook, error: fetchError } = await supabase
      .from('webhooks_inbox')
      .select('*')
      .eq('id', webhookId)
      .single()
    
    if (fetchError) {
      console.error('Error fetching webhook:', fetchError)
      return { success: false, error: fetchError.message }
    }
    
    const shopifyOrder = webhook.payload
    const shopDomain = webhook.shop_domain || ''
    
    // Determine store source
    const storeSource = shopDomain.includes('flour-lane') ? 'Flourlane' : 'Bannos'
    
    console.log(`Processing ${storeSource} order: ${shopifyOrder.order_number}`)
    
    // NO TAGS REJECTION RULE (from Lovable)
    // Only reject if completely empty AND no legitimacy indicators
    const orderTags = shopifyOrder.tags || ''
    if (!orderTags || orderTags.trim() === '') {
      const hasDeliveryInfo = shopifyOrder.note_attributes?.some(attr =>
        attr.name?.toLowerCase().includes('delivery')
      )
      const hasCustomer = shopifyOrder.customer?.first_name && shopifyOrder.customer?.last_name
      const hasLineItems = shopifyOrder.line_items?.length > 0
      
      if (!hasDeliveryInfo && !hasCustomer && !hasLineItems) {
        console.log(`Rejecting order - no tags and no legitimacy indicators`)
        return { success: false, error: 'No tags and insufficient data' }
      }
    }
    
    // Process order items and apply splitting logic
    const orders = await processOrderItems(shopifyOrder, storeSource)
    
    if (orders.length === 0) {
      console.log('No orders to process')
      return { success: true, message: 'No production items' }
    }
    
    // Insert into appropriate table
    const orderTable = storeSource === 'Flourlane' 
      ? 'orders_table_flourlane'
      : 'orders_table_bannos'
    
    for (const order of orders) {
      console.log(`Inserting order: ${order.id}`)
      
      const { error: insertError } = await supabase
        .from(orderTable)
        .upsert(order, {
          onConflict: 'id',
          ignoreDuplicates: false
        })
      
      if (insertError) {
        console.error('Error inserting order:', insertError)
        return { success: false, error: insertError.message }
      }
    }
    
    console.log(`Successfully processed ${orders.length} order(s)`)
    
    return { 
      success: true, 
      ordersCreated: orders.length,
      orderIds: orders.map(o => o.id)
    }
    
  } catch (error) {
    console.error('Processor error:', error)
    return { success: false, error: error.message }
  }
}

// ============================================================================
// BATCH PROCESSOR - Process all unprocessed webhooks
// ============================================================================

export async function processPendingWebhooks() {
  try {
    // Fetch unprocessed webhooks
    const { data: webhooks, error: fetchError } = await supabase
      .from('webhooks_inbox')
      .select('*')
      .eq('processed', false)
      .order('created_at', { ascending: true })
    
    if (fetchError) {
      console.error('Error fetching webhooks:', fetchError)
      return { success: false, error: fetchError.message }
    }
    
    console.log(`Found ${webhooks.length} unprocessed webhooks`)
    
    const results = []
    
    for (const webhook of webhooks) {
      const result = await processWebhook(webhook.id)
      results.push({
        webhookId: webhook.id,
        ...result
      })
      
      // Mark as processed if successful
      if (result.success) {
        await supabase
          .from('webhooks_inbox')
          .update({ processed: true, processed_at: new Date().toISOString() })
          .eq('id', webhook.id)
      }
    }
    
    return {
      success: true,
      totalProcessed: results.filter(r => r.success).length,
      totalFailed: results.filter(r => !r.success).length,
      results
    }
    
  } catch (error) {
    console.error('Batch processor error:', error)
    return { success: false, error: error.message }
  }
}

