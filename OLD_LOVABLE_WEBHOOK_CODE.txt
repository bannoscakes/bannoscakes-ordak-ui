// Paste your old Lovable project webhook code here
// This file is for comparison purposes only


import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

// Verify Shopify webhook signature
async function verifyShopifyWebhook(body: string, signature: string, secret: string): Promise<boolean> {
  const encoder = new TextEncoder()
  const key = await crypto.subtle.importKey(
    'raw',
    encoder.encode(secret),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  )
  
  const expectedSignature = await crypto.subtle.sign('HMAC', key, encoder.encode(body))
  const expectedHex = 'sha256=' + Array.from(new Uint8Array(expectedSignature))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('')
  
  console.log('Signature verification details:', {
    receivedSignature: signature,
    calculatedSignature: expectedHex,
    secretExists: !!secret,
    bodyLength: body.length
  })
  
  return expectedHex === signature
}

function getStoreSource(shopDomain: string): 'Bannos' | 'Flourlane' {
  if (shopDomain?.includes('bannos')) return 'Bannos'
  if (shopDomain?.includes('flour-lane')) return 'Flourlane'
  return 'Bannos' // default
}

function parseDeliveryDate(shopifyOrder: any): Date | null {
  console.log('Parsing delivery date for order:', shopifyOrder.id)
  
  // Method 1: Check note_attributes for 'Local Delivery Date and Time'
  const noteAttributes = shopifyOrder.note_attributes || []
  console.log('Note attributes:', JSON.stringify(noteAttributes, null, 2))
  
  // Look specifically for 'Local Delivery Date and Time' attribute
  const deliveryDateAttr = noteAttributes.find((attr: any) => 
    attr.name === 'Local Delivery Date and Time'
  )
  
  if (deliveryDateAttr && deliveryDateAttr.value) {
    console.log(`Found delivery date attribute: ${deliveryDateAttr.name} = ${deliveryDateAttr.value}`)
    
    // Parse formats like "Fri 25 Jul 2025 between 9:00 AM and 6:00 PM"
    const dateText = deliveryDateAttr.value
    // Extract date part before "between"
    const datePart = dateText.split(' between ')[0]
    console.log('Extracted date part:', datePart)
    
    try {
      const parsedDate = new Date(datePart)
      if (!isNaN(parsedDate.getTime())) {
        console.log('Successfully parsed delivery date:', parsedDate.toISOString())
        return parsedDate
      }
    } catch (error) {
      console.log('Failed to parse date part:', error)
    }
  }
  
  // Fallback: Check other delivery-related attributes
  for (const attr of noteAttributes) {
    if (attr.name && attr.name.toLowerCase().includes('delivery') && attr.name !== 'Local Delivery Date and Time') {
      console.log(`Found fallback delivery attribute: ${attr.name} = ${attr.value}`)
      
      const dateText = attr.value
      if (dateText) {
        const datePart = dateText.split(' between ')[0]
        console.log('Extracted date part:', datePart)
        
        try {
          const parsedDate = new Date(datePart)
          if (!isNaN(parsedDate.getTime())) {
            console.log('Successfully parsed delivery date from fallback:', parsedDate.toISOString())
            return parsedDate
          }
        } catch (error) {
          console.log('Failed to parse fallback date part:', error)
        }
      }
    }
  }
  
  // Method 2: Check line item properties for delivery_id (base64 encoded) - exclude system keys
  const lineItems = shopifyOrder.line_items || []
  for (const item of lineItems) {
    const properties = item.properties || []
    for (const prop of properties) {
      // Skip system keys
      if (prop.name && (prop.name.startsWith('_') || prop.name === 'delivery_id')) {
        continue
      }
      
      if (prop.name && prop.name.toLowerCase().includes('delivery') && prop.value) {
        try {
          console.log('Found delivery property:', prop.name, '=', prop.value)
          const parsedDate = new Date(prop.value)
          if (!isNaN(parsedDate.getTime())) {
            console.log('Successfully parsed date from property:', parsedDate.toISOString())
            return parsedDate
          }
        } catch (error) {
          console.log('Failed to parse property date:', error)
        }
      }
    }
  }
  
  // Method 3: Check for fulfillment_date in the order
  if (shopifyOrder.fulfillment_date) {
    try {
      const parsedDate = new Date(shopifyOrder.fulfillment_date)
      if (!isNaN(parsedDate.getTime())) {
        console.log('Using fulfillment_date:', parsedDate.toISOString())
        return parsedDate
      }
    } catch (error) {
      console.log('Failed to parse fulfillment_date:', error)
    }
  }
  
  // No valid delivery date found - return null instead of fallback
  console.log('No valid delivery date found, returning null')
  return null
}

function isCakeItem(item: any): boolean {
  const title = (item.title || '').toLowerCase()
  
  // PRIORITY 1: If it's an accessory, it's NOT a cake
  if (isAccessoryItem(item)) {
    console.log(`Item "${item.title}" is an accessory, not a cake`)
    return false
  }
  
  // PRIORITY 2: Check if it contains "cake" but exclude common accessory patterns
  if (title.includes('cake')) {
    // Additional exclusions for accessories that might contain "cake"
    if (title.includes('topper') || title.includes('decoration') || title.includes('pick')) {
      console.log(`Item "${item.title}" contains "cake" but is an accessory`)
      return false
    }
    
    console.log(`Item "${item.title}" identified as a cake`)
    return true
  }
  
  console.log(`Item "${item.title}" is not a cake`)
  return false
}

function isAccessoryItem(item: any): boolean {
  const title = (item.title || '').toLowerCase()
  return title.includes('candle') || title.includes('balloon') || title.includes('topper')
}

async function extractImageFromItem(item: any, storeSource: 'Bannos' | 'Flourlane' = 'Bannos'): Promise<string | null> {
  console.log('Extracting image for item:', item.title)
  
  // PRIORITY 1: Check line_item.image first (same as kitchen docket pattern)
  if (item.image) {
    console.log('Found image in item.image:', item.image)
    return item.image
  }
  
  // PRIORITY 2: Check line_item.product.featured_image as fallback
  if (item.product && item.product.featured_image) {
    console.log('Found image in item.product.featured_image:', item.product.featured_image)
    return item.product.featured_image
  }
  
  // PRIORITY 3: Fetch from Shopify Admin API using product_id
  if (item.product_id || (item.product && item.product.id)) {
    const productId = item.product_id || item.product.id;
    console.log('Attempting to fetch image from Shopify API for product:', productId);
    
    try {
      // Use the correct admin token and store domain based on store source
      const adminToken = storeSource === 'Flourlane' 
        ? Deno.env.get('SHOPIFY_ADMIN_TOKEN_FLOURLANE')
        : Deno.env.get('SHOPIFY_ADMIN_TOKEN');
      
      const storeDomain = storeSource === 'Flourlane' 
        ? 'flour-lane.myshopify.com'
        : 'bannos.myshopify.com';

      if (!adminToken) {
        const tokenName = storeSource === 'Flourlane' 
          ? 'SHOPIFY_ADMIN_TOKEN_FLOURLANE'
          : 'SHOPIFY_ADMIN_TOKEN';
        console.error(`${tokenName} not found, cannot fetch images`);
        return null;
      }

      const shopifyProductId = `gid://shopify/Product/${productId}`;
      const query = `
        query getProductImages($id: ID!) {
          product(id: $id) {
            images(first: 5) {
              edges {
                node {
                  originalSrc
                  altText
                }
              }
            }
          }
        }
      `;

      const response = await fetch(`https://${storeDomain}/admin/api/2025-01/graphql.json`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Shopify-Access-Token': adminToken,
        },
        body: JSON.stringify({
          query,
          variables: { id: shopifyProductId }
        }),
      });

      if (response.ok) {
        const data = await response.json();
        const images = data.data?.product?.images?.edges || [];
        if (images.length > 0) {
          const imageUrl = images[0].node.originalSrc;
          console.log('Successfully fetched image from Shopify API:', imageUrl);
          return imageUrl;
        }
      }
    } catch (error) {
      console.error('Failed to fetch image from Shopify API:', error);
    }
  }
  
  console.log('No image found for item')
  return null
}

// Helper function to detect pre-flavored products
function isPreFlavoredProduct(productTitle: string): boolean {
  if (!productTitle) return false
  
  const title = productTitle.toLowerCase()
  
  // Pre-flavored gelato cakes (excluding 2-flavor custom selections)
  const preFlavoredPatterns = [
    'cookies and cream gelato',
    'biscoff gelato',
    'nutella gelato', 
    'sorbet cake',
    'chocolate mud cake',
    'carrot cake',
    'red velvet cake'
  ]
  
  return preFlavoredPatterns.some(pattern => title.includes(pattern))
}

function extractFlavorFromItem(item: any): string | null {
  const props = Array.isArray(item?.properties) ? item.properties : []
  const keep: string[] = []

  for (const prop of props) {
    // Shopify sometimes uses { name, value }; sometimes { first, last }
    const name = (prop?.name ?? prop?.first ?? '').toString()
    const value = (prop?.value ?? prop?.last ?? '').toString()

    // Match the Liquid {% unless %} filters in your docket
    if (!name) continue
    if (
      name.includes('_origin') ||
      name.includes('_raw') ||
      name.includes('gwp') ||
      name.includes('_LocalDeliveryID') ||
      name.startsWith('_')
    ) {
      continue
    }

    // Same as: {% if property.last != blank %} ... {{ property.first }}: {{ property.last }}
    if (value.trim() !== '') {
      keep.push(`${name}: ${value}`)
    }
  }

  return keep.length ? keep.join(' | ') : null
}

function extractWritingOnCakeFromItem(item: any, shopifyOrder: any): string | null {
  console.log('Extracting writing on cake for item:', item.title)
  
  // Primary method: Check order properties for writing (Flour Lane specific)
  if (shopifyOrder.note_attributes) {
    const writingAttr = shopifyOrder.note_attributes.find((attr: any) => 
      attr.name && attr.name.toLowerCase().includes('writing')
    )
    if (writingAttr && writingAttr.value) {
      console.log(`Found writing in order properties: ${writingAttr.name} = ${writingAttr.value}`)
      return writingAttr.value
    }
  }
  
  // Secondary method: Check item properties for writing/inscription information
  const properties = item.properties || []
  for (const prop of properties) {
    if (prop.name && (
      prop.name.toLowerCase().includes('writing') ||
      prop.name.toLowerCase().includes('inscription') ||
      prop.name.toLowerCase().includes('message') ||
      prop.name.toLowerCase().includes('text')
    )) {
      console.log(`Found writing in item properties: ${prop.name} = ${prop.value}`)
      return prop.value || null
    }
  }
  
  console.log('No writing on cake found')
  return null
}

function extractCakeSizeFromItem(item: any, shopifyOrder: any): string {
  console.log('Extracting cake size for item:', item.title)
  
  // Primary method: Check order properties for size (Flour Lane specific)
  if (shopifyOrder.note_attributes) {
    const sizeAttr = shopifyOrder.note_attributes.find((attr: any) => 
      attr.name && attr.name.toLowerCase() === 'size'
    )
    if (sizeAttr && sizeAttr.value) {
      console.log(`Found size in order properties: ${sizeAttr.name} = ${sizeAttr.value}`)
      return sizeAttr.value
    }
  }
  
  // Secondary method: Check item properties for size information
  const properties = item.properties || []
  for (const prop of properties) {
    if (prop.name && prop.name.toLowerCase().includes('size')) {
      console.log(`Found size in item properties: ${prop.name} = ${prop.value}`)
      return prop.value || 'Medium'
    }
  }
  
  // Fallback: Check variant title for size - check for compound sizes first
  if (item.variant_title) {
    const variantTitle = item.variant_title.toLowerCase()
    console.log('Checking variant title for size:', item.variant_title)
    
    if (variantTitle.includes('gift size')) return 'Gift Size'
    if (variantTitle.includes('small tall')) return 'Small Tall'
    if (variantTitle.includes('medium tall')) return 'Medium Tall'
    if (variantTitle.includes('large tall')) return 'Large Tall'
    if (variantTitle.includes('small')) return 'Small'
    if (variantTitle.includes('medium')) return 'Medium'
    if (variantTitle.includes('large')) return 'Large'
  }
  
  console.log('No size found, using default: Medium')
  return 'Medium'
}

function getCakeTypeFromItem(item: any): string {
  const productTitle = (item.title || '').toLowerCase()
  
  console.log('Determining cake type from product:', item.title)
  
  if (productTitle.includes('gelato')) return 'Gelato Cake'
  if (productTitle.includes('birthday')) return 'Birthday Cake'
  if (productTitle.includes('wedding')) return 'Wedding Cake'
  if (productTitle.includes('cupcake')) return 'Cupcakes'
  if (productTitle.includes('custom')) return 'Custom Cake'
  
  // Return the actual product title if no specific type found
  return item.title || 'Custom Cake'
}

async function processOrderItems(shopifyOrder: any, storeSource: 'Bannos' | 'Flourlane') {
  console.log('Processing order items for order:', shopifyOrder.id)
  
  const lineItems = shopifyOrder.line_items || []
  const cakeItems = []
  const accessoryItems = []
  
  // Categorize items
  for (const item of lineItems) {
    console.log('Processing item:', {
      title: item.title,
      quantity: item.quantity,
      isCake: isCakeItem(item),
      isAccessory: isAccessoryItem(item)
    })
    
    if (isCakeItem(item)) {
      // Add each cake as a separate item (respecting quantity)
      for (let i = 0; i < item.quantity; i++) {
        cakeItems.push(item)
      }
    } else if (isAccessoryItem(item)) {
      accessoryItems.push(item)
    }
  }
  
  console.log('Categorized items:', {
    cakeCount: cakeItems.length,
    accessoryCount: accessoryItems.length
  })
  
  // Create accessories array for database storage
  const accessoriesForDB = accessoryItems.map(item => ({
    title: item.title,
    quantity: item.quantity,
    shopify_variant_id: item.variant_id?.toString(),
    shopify_product_id: item.product_id?.toString(),
    price: item.price,
    vendor: item.vendor,
    product_type: item.product_type,
    variant_title: item.variant_title
  }))
  
  // Extract delivery date and common order info
  const deliveryDate = parseDeliveryDate(shopifyOrder)
  
  if (!deliveryDate) {
    console.log('Order rejected - no valid delivery date found')
    return []
  }
  
  const deliveryDay = deliveryDate.toLocaleDateString('en-US', { weekday: 'long' })
  
  // Extract fulfillment type from 'Delivery Method' attribute (Bannos specific logic)
  let fulfillmentType = 'delivery' // default
  
  if (storeSource === 'Bannos') {
    // For Bannos, check note_attributes for 'Delivery Method'
    const noteAttributes = shopifyOrder.note_attributes || []
    const deliveryMethodAttr = noteAttributes.find((attr: any) => 
      attr.name === 'Delivery Method'
    )
    
    if (deliveryMethodAttr && deliveryMethodAttr.value) {
      console.log(`Found delivery method: ${deliveryMethodAttr.name} = ${deliveryMethodAttr.value}`)
      const methodValue = deliveryMethodAttr.value.toLowerCase()
      
      if (methodValue.includes('pick up') || methodValue.includes('pickup')) {
        fulfillmentType = 'pickup'
      } else if (methodValue.includes('delivery') || methodValue.includes('local delivery')) {
        fulfillmentType = 'delivery'
      }
    } else {
      // Fallback to shipping address check for Bannos
      fulfillmentType = shopifyOrder.shipping_address ? 'delivery' : 'pickup'
    }
  } else {
    // For Flour Lane, keep existing logic (shipping address check)
    fulfillmentType = shopifyOrder.shipping_address ? 'delivery' : 'pickup'
  }
  
  console.log('Fulfillment type:', fulfillmentType)
  
  // Determine priority
  const daysUntilDelivery = Math.ceil((deliveryDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24))
  const orderNote = (shopifyOrder.note || '').toLowerCase()
  const tags = (shopifyOrder.tags || '').toLowerCase()
  
  let priority: 'high' | 'medium' | 'low' = 'medium'
  if (daysUntilDelivery <= 1 || orderNote.includes('rush') || orderNote.includes('urgent') || 
      tags.includes('rush') || tags.includes('urgent')) {
    priority = 'high'
  } else if (daysUntilDelivery <= 3) {
    priority = 'medium'
  } else {
    priority = 'low'
  }
  
  const orders = []
  
  // Skip accessory-only orders (no production needed)
  if (cakeItems.length === 0) {
    console.log('Skipping accessory-only order - no production items found')
    return []
  }
  
  // If only one cake, create single order
  if (cakeItems.length <= 1) {
    console.log('Creating single order (no splitting needed)')
    
    const cakeItem = cakeItems[0]
    const cakeQuantity = 1 // Always 1 since we know there's exactly 1 cake
    
      const order = {
        id: `${storeSource === 'Flourlane' ? 'flour-lane' : 'bannos'}-${shopifyOrder.order_number}`,
        customer_name: `${sÃ¥hopifyOrder.customer?.first_name || ''} ${shopifyOrder.customer?.last_name || ''}`.trim() || 'Customer',
        cake_type: cakeItem ? getCakeTypeFromItem(cakeItem) : 'Custom Order',
        flavor: cakeItem ? extractFlavorFromItem(cakeItem) : null,
        quantity: cakeQuantity, // Just the cake quantity, accessories shown separately
        delivery_date: deliveryDate.toISOString(),
        delivery_day: deliveryDay,
        status: 'new-order',
        priority: priority,
        current_stage: 'Order received',
        fulfillment_type: fulfillmentType,
        store_source: storeSource === 'Flourlane' ? 'flour_lane' : 'Bannos',
        shopify_order_id: shopifyOrder.id.toString(),
        customer_email: shopifyOrder.customer?.email || shopifyOrder.email,
        order_notes: shopifyOrder.note || '',
        assigned_staff: null,
        order_number: `${storeSource === 'Bannos' ? 'B' : 'F'}${shopifyOrder.order_number}`,
        product_title: cakeItem ? cakeItem.title : lineItems[0]?.title || 'Custom Order',
        cake_size: cakeItem ? extractCakeSizeFromItem(cakeItem, shopifyOrder) : null,
        writing_on_cake: cakeItem ? extractWritingOnCakeFromItem(cakeItem, shopifyOrder) : null,
        product_image: cakeItem ? await extractImageFromItem(cakeItem, storeSource) : (lineItems[0] ? await extractImageFromItem(lineItems[0], storeSource) : null),
        accessories: accessoriesForDB
      }
        orders.push(order)
    
  } else {
    // Multiple cakes - split into separate orders
    console.log(`Creating ${cakeItems.length} split orders for multiple cakes`)
    
    const suffixes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']
    
    for (let i = 0; i < cakeItems.length; i++) {
      const cakeItem = cakeItems[i]
      const suffix = suffixes[i] || (i + 1).toString()
      
      // For split orders: 1 cake per order, accessories only on first order
      const isFirstOrder = i === 0
      const orderAccessories = isFirstOrder ? accessoriesForDB : []
      
        const order = {
          id: `${storeSource === 'Flourlane' ? 'flour-lane' : 'bannos'}-${shopifyOrder.order_number}-${suffix}`,
          customer_name: `${shopifyOrder.customer?.first_name || ''} ${shopifyOrder.customer?.last_name || ''}`.trim() || 'Customer',
          cake_type: getCakeTypeFromItem(cakeItem),
          flavor: extractFlavorFromItem(cakeItem),
          quantity: 1, // Always 1 cake per split order
          delivery_date: deliveryDate.toISOString(),
          delivery_day: deliveryDay,
          status: 'new-order',
          priority: priority,
          current_stage: 'Order received',
          fulfillment_type: fulfillmentType,
          store_source: storeSource === 'Flourlane' ? 'flour_lane' : 'Bannos',
          shopify_order_id: shopifyOrder.id.toString(),
          customer_email: shopifyOrder.customer?.email || shopifyOrder.email,
          order_notes: shopifyOrder.note || '',
          assigned_staff: null,
          order_number: `${storeSource === 'Bannos' ? 'B' : 'F'}${shopifyOrder.order_number}-${suffix}`,
          product_title: cakeItem.title,
          cake_size: extractCakeSizeFromItem(cakeItem, shopifyOrder),
          writing_on_cake: extractWritingOnCakeFromItem(cakeItem, shopifyOrder),
          product_image: await extractImageFromItem(cakeItem, storeSource),
          accessories: orderAccessories
        }
      
      orders.push(order)
    }
  }
  
  return orders
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders })
  }

  try {
    // Initialize Supabase client with service role key to bypass RLS
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const supabase = createClient(supabaseUrl, supabaseServiceKey)

    // Get webhook headers
    const signature = req.headers.get('x-shopify-hmac-sha256')
    const topic = req.headers.get('x-shopify-topic')
    const shopDomain = req.headers.get('x-shopify-shop-domain')

    console.log('Webhook received:', {
      topic,
      shopDomain,
      signature: !!signature,
      bodySize: req.headers.get('content-length')
    })

    // Read the request body
    const body = await req.text()
    
    // Parse the order data
    const shopifyOrder = JSON.parse(body)
    
    console.log('Webhook data parsed successfully:', {
      orderId: shopifyOrder.id,
      orderNumber: shopifyOrder.order_number,
      customerName: `${shopifyOrder.customer?.first_name} ${shopifyOrder.customer?.last_name}`,
      lineItemsCount: shopifyOrder.line_items?.length || 0,
      noteAttributesCount: shopifyOrder.note_attributes?.length || 0
    })

    // Determine which webhook secret to use based on shop domain
    const storeSource = getStoreSource(shopDomain || '')
    const webhookSecret = storeSource === 'Flourlane' 
      ? Deno.env.get('SHOPIFY_WEBHOOK_SECRET F')
      : Deno.env.get('SHOPIFY_WEBHOOK_SECRET')

    if (!webhookSecret) {
      const secretName = storeSource === 'Flourlane' 
        ? 'SHOPIFY_WEBHOOK_SECRET F'
        : 'SHOPIFY_WEBHOOK_SECRET'
      console.error(`${secretName} not found in environment`)
      return new Response(`Webhook secret not configured for ${storeSource}`, { status: 500 })
    }

    // Verify the webhook signature (temporarily disabled for testing)
    console.log('DEBUG MODE: Signature verification temporarily disabled')
    // const isValid = await verifyShopifyWebhook(body, signature!, webhookSecret)
    // if (!isValid) {
    //   console.error('Invalid webhook signature')
    //   return new Response('Invalid signature', { status: 401 })
    // }

    // Log webhook event to appropriate table based on store
    const webhookTable = storeSource === 'Flourlane' ? 'flour_lane_webhook_events' : 'bannos_webhook_events'
    try {
      const { error: logError } = await supabase
        .from(webhookTable)
        .insert({
          topic: topic || 'unknown',
          shop_domain: shopDomain,
          data: shopifyOrder,
          store_source: storeSource
        })

      if (logError) {
        console.error('Error logging webhook to', webhookTable, ':', logError)
      }
    } catch (webhookLogError) {
      console.error('Failed to log webhook event:', webhookLogError)
    }

    // Process order creation webhooks
    if (topic === 'orders/create') {
      try {
        // Normalize order_number with fallbacks
        const normalizedOrderNumber = shopifyOrder.order_number ?? 
          shopifyOrder.name?.replace(/^#/, '') ?? 
          shopifyOrder.id?.toString()
        
        if (!normalizedOrderNumber) {
          console.error(`Order rejected - Cannot derive order number. Order ID: ${shopifyOrder.id}`)
          return new Response('Order rejected - Cannot derive order number', { status: 400, headers: corsHeaders })
        }
        
        // Warn if we had to use fallback
        if (!shopifyOrder.order_number) {
          console.log(`Warning: order_number missing; using fallback: ${normalizedOrderNumber}`)
        }
        
        // Assign normalized value back so existing code continues to work
        shopifyOrder.order_number = normalizedOrderNumber
        
        // Relaxed validation: Allow orders with legitimacy indicators
        const orderTags = shopifyOrder.tags || ''
        if (!orderTags || orderTags.trim() === '') {
          const hasDeliveryInfo = shopifyOrder.note_attributes?.some(attr => 
            attr.name?.toLowerCase().includes('delivery')
          )
          const hasCustomer = shopifyOrder.customer?.first_name && shopifyOrder.customer?.last_name
          const hasLineItems = shopifyOrder.line_items?.length > 0
          
          // Block only if it looks like a test order (no legitimacy indicators)
          if (!hasDeliveryInfo && !hasCustomer && !hasLineItems) {
            console.log(`Blocking ${storeSource} order ${shopifyOrder.order_number} - No tags and no legitimacy indicators`)
            return new Response('Order blocked - No tags and insufficient data', { headers: corsHeaders })
          } else {
            console.log(`Allowing ${storeSource} order ${shopifyOrder.order_number} without tags - Has legitimacy indicators (delivery: ${!!hasDeliveryInfo}, customer: ${!!hasCustomer}, items: ${!!hasLineItems})`)
          }
        }
        
        console.log(`Order ${shopifyOrder.order_number} has tags: "${orderTags}" - Processing...`)
        
        const orders = await processOrderItems(shopifyOrder, storeSource)
        
        // Skip if no orders to process (accessory-only)
        if (orders.length === 0) {
          console.log('No orders to process - skipping database insertion')
          return new Response('OK - No production items', { headers: corsHeaders })
        }
        
        console.log(`Processing ${orders.length} orders for database insertion`)
        
        // Idempotent upsert all orders to appropriate table based on store
        const orderTable = storeSource === 'Flourlane' ? 'flour_lane_orders' : 'bannos_orders'
        for (const order of orders) {
          console.log('Upserting order to table:', orderTable, {
            id: order.id,
            customerName: order.customer_name,
            cakeType: order.cake_type,
            deliveryDate: order.delivery_date,
            storeSource: order.store_source
          })
          
          // CRITICAL DEBUG: Log exact flavor value before upsert
          console.log('Flavor value about to insert:', JSON.stringify(order.flavor))
          console.log('Flavor type:', typeof order.flavor)
          console.log('Flavor length:', order.flavor?.length || 'N/A')
          
          const { error: orderError } = await supabase
            .from(orderTable)
            .upsert(order, { 
              onConflict: 'id',
              ignoreDuplicates: false 
            })

          if (orderError) {
            console.error('Error upserting order:', orderError)
            return new Response('Error processing order', { status: 500, headers: corsHeaders })
          }
        }

        console.log(`Successfully processed ${orders.length} orders`)
        
        // INVENTORY SYSTEM DISABLED - Process orders for inventory deduction
        console.log('Inventory processing disabled - skipping inventory deduction');
        /* DISABLED INVENTORY PROCESSING
        try {
          const orderItems = shopifyOrder.line_items.map((item: any) => ({
            product_id: item.product_id.toString(),
            variant_id: item.variant_id.toString(),
            quantity: item.quantity,
            title: item.title,
            variant_title: item.variant_title
          }));

          const { error: processError } = await supabase.functions.invoke('inventory-order-processor', {
            body: {
              order_id: orders[0].id, // Use first order ID for tracking
              items: orderItems
            }
          });

          if (processError) {
            console.error('Error processing order for inventory:', processError);
          } else {
            console.log('Order processed for inventory deduction');
          }
        } catch (error) {
          console.error('Error calling inventory processor:', error);
        }
        */
        
      } catch (orderProcessingError) {
        console.error('Order processing failed:', orderProcessingError)
        return new Response('Order processing failed', { status: 500, headers: corsHeaders })
      }
    }

    return new Response('OK', { headers: corsHeaders })
  } catch (error) {
    console.error('Webhook processing error:', error)
    return new Response('Internal Server Error', { status: 500, headers: corsHeaders })
  }
})
