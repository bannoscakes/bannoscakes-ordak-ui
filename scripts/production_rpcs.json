[
    {
      "function_name": "_order_lock",
      "function_definition": "CREATE OR REPLACE FUNCTION public._order_lock(p_order_id uuid)\n RETURNS void\n LANGUAGE sql\nAS $function$\n  select pg_advisory_xact_lock(hashtext(p_order_id::text));\n$function$\n"
    },
    {
      "function_name": "add_bom_component",
      "function_definition": "CREATE OR REPLACE FUNCTION public.add_bom_component(p_bom_id uuid, p_component_id uuid, p_quantity_required numeric, p_unit text DEFAULT 'each'::text, p_is_optional boolean DEFAULT false, p_notes text DEFAULT NULL::text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_item_id uuid;\nBEGIN\n  INSERT INTO public.bom_items (bom_id, component_id, quantity_required, unit, is_optional, notes)\n  VALUES (p_bom_id, p_component_id, p_quantity_required, p_unit, p_is_optional, p_notes)\n  ON CONFLICT (bom_id, component_id) \n  DO UPDATE SET \n    quantity_required = p_quantity_required,\n    unit = p_unit,\n    is_optional = p_is_optional,\n    notes = p_notes\n  RETURNING id INTO v_item_id;\n  \n  RETURN v_item_id;\nEND;\n$function$\n"
    },
    {
      "function_name": "add_participant",
      "function_definition": "CREATE OR REPLACE FUNCTION public.add_participant(p_conversation_id uuid, p_user_id uuid)\n RETURNS boolean\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n  insert into public.conversation_participants(conversation_id, user_id)\n  values (p_conversation_id, p_user_id)\n  on conflict do nothing;\n  select true;\n$function$\n"
    },
    {
      "function_name": "add_participant",
      "function_definition": "CREATE OR REPLACE FUNCTION public.add_participant(p_conversation_id text, p_user_id text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  INSERT INTO public.conversation_participants (conversation_id, user_id)\n  VALUES (p_conversation_id::uuid, p_user_id::uuid)\n  ON CONFLICT (conversation_id, user_id) DO NOTHING;\n  \n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "add_product_requirement",
      "function_definition": "CREATE OR REPLACE FUNCTION public.add_product_requirement(p_shopify_product_id text, p_shopify_variant_id text, p_product_title text, p_component_id uuid, p_quantity_per_unit numeric, p_is_optional boolean DEFAULT false, p_auto_deduct boolean DEFAULT true)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_req_id uuid;\nBEGIN\n  INSERT INTO public.product_requirements (\n    shopify_product_id, shopify_variant_id, product_title, \n    component_id, quantity_per_unit, is_optional, auto_deduct\n  )\n  VALUES (\n    p_shopify_product_id, p_shopify_variant_id, p_product_title,\n    p_component_id, p_quantity_per_unit, p_is_optional, p_auto_deduct\n  )\n  RETURNING id INTO v_req_id;\n  \n  RETURN v_req_id;\nEND;\n$function$\n"
    },
    {
      "function_name": "admin_delete_order",
      "function_definition": "CREATE OR REPLACE FUNCTION public.admin_delete_order(p_order_id uuid)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nbegin\n  delete from stage_events  where order_id = p_order_id;\n  delete from work_queue    where order_id = p_order_id;\n  delete from order_photos  where order_id = p_order_id;\n  delete from audit_log     where order_id = p_order_id;\n  delete from dead_letter   where payload->>'order_id' = p_order_id::text;\n  delete from orders        where id = p_order_id;\nend; $function$\n"
    },
    {
      "function_name": "alpha_suffix",
      "function_definition": "CREATE OR REPLACE FUNCTION public.alpha_suffix(p_idx integer)\n RETURNS text\n LANGUAGE plpgsql\n IMMUTABLE\nAS $function$\ndeclare\n  n int := p_idx;\n  s text := '';\n  r int;\nbegin\n  if n < 0 then\n    return 'A';\n  end if;\n  loop\n    r := n % 26;\n    s := chr(65 + r) || s;   -- 65 = 'A'\n    n := (n / 26) - 1;       -- 0-based to Excel-like\n    exit when n < 0;\n  end loop;\n  return s;\nend;\n$function$\n"
    },
    {
      "function_name": "app_can_access_store",
      "function_definition": "CREATE OR REPLACE FUNCTION public.app_can_access_store(s text)\n RETURNS boolean\n LANGUAGE sql\n STABLE\nAS $function$\nselect\n  app_role() = 'Admin'\n  or exists (\n    select 1\n    from users u\n    where u.email = auth_email()\n      and (u.store_access @> array[s]::text[])\n  );\n$function$\n"
    },
    {
      "function_name": "app_is_service_role",
      "function_definition": "CREATE OR REPLACE FUNCTION public.app_is_service_role()\n RETURNS boolean\n LANGUAGE sql\n STABLE\nAS $function$\nselect coalesce((current_setting('request.jwt.claims', true)::jsonb ->> 'role'), '') = 'service_role';\n$function$\n"
    },
    {
      "function_name": "app_role",
      "function_definition": "CREATE OR REPLACE FUNCTION public.app_role()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\nselect coalesce( (select role from users where email = auth_email() limit 1), 'Staff');\n$function$\n"
    },
    {
      "function_name": "assign_staff",
      "function_definition": "CREATE OR REPLACE FUNCTION public.assign_staff(p_order_id text, p_store text, p_staff_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_table_name text;\nBEGIN\n  v_table_name := 'orders_' || p_store;\n  \n  EXECUTE format('UPDATE public.%I SET assignee_id = $1, updated_at = now() WHERE id = $2', v_table_name)\n  USING p_staff_id, p_order_id;\n  \n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "assign_staff_to_order",
      "function_definition": "CREATE OR REPLACE FUNCTION public.assign_staff_to_order(p_order_id uuid, p_staff_id uuid)\n RETURNS orders\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_before public.stage;\n  v_after  public.stage;\n  v_row    public.orders;\nbegin\n  perform public._order_lock(p_order_id);\n\n  select stage into v_before from public.orders where id = p_order_id for update;\n  if not found then raise exception 'ORDER_NOT_FOUND'; end if;\n\n  update public.orders\n     set assignee_id = p_staff_id,\n         stage = case\n                   when stage = 'Covering_pending' then 'Covering_in_progress'\n                   when stage = 'Decorating_pending' then 'Decorating_in_progress'\n                   else stage\n                 end,\n         updated_at = now()\n   where id = p_order_id\n  returning * into v_row;\n\n  v_after := v_row.stage;\n  if v_after is distinct from v_before then\n    insert into public.stage_events(order_id, from_stage, to_stage, performed_by, reason)\n    values (p_order_id, v_before, v_after, null, 'assign_staff');\n  end if;\n\n  insert into public.audit_log(action, performed_by, source, meta)\n  values ('assign_staff_to_order', null, 'rpc', jsonb_build_object('order_id', p_order_id, 'staff_id', p_staff_id));\n\n  return v_row;\nend\n$function$\n"
    },
    {
      "function_name": "auth_email",
      "function_definition": "CREATE OR REPLACE FUNCTION public.auth_email()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\nselect coalesce( (current_setting('request.jwt.claims', true)::jsonb ->> 'email'), '' );\n$function$\n"
    },
    {
      "function_name": "complete_covering",
      "function_definition": "CREATE OR REPLACE FUNCTION public.complete_covering(p_order_id uuid)\n RETURNS orders\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_before public.stage;\n  v_after  public.stage;\n  v_row    public.orders;\nbegin\n  perform public._order_lock(p_order_id);\n\n  select stage into v_before from public.orders where id = p_order_id for update;\n  if not found then raise exception 'ORDER_NOT_FOUND'; end if;\n\n  update public.orders\n     set covering_complete_ts = coalesce(covering_complete_ts, now()),\n         stage = case when v_before = 'Covering_in_progress' then 'Decorating_pending' else stage end,\n         updated_at = now()\n   where id = p_order_id\n  returning * into v_row;\n\n  v_after := v_row.stage;\n  if v_after is distinct from v_before then\n    insert into public.stage_events(order_id, from_stage, to_stage, performed_by, reason)\n    values (p_order_id, v_before, v_after, null, 'complete_covering');\n  end if;\n\n  insert into public.audit_log(action, performed_by, source, meta)\n  values ('complete_covering', null, 'rpc', jsonb_build_object('order_id', p_order_id));\n\n  return v_row;\nend\n$function$\n"
    },
    {
      "function_name": "complete_covering",
      "function_definition": "CREATE OR REPLACE FUNCTION public.complete_covering(p_order_id text, p_store text, p_notes text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_table_name text;\n  v_user_id uuid;\nBEGIN\n  v_table_name := 'orders_' || p_store;\n  v_user_id := COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::uuid);\n  \n  EXECUTE format('UPDATE public.%I SET stage = ''Decorating'', covering_complete_ts = now(), updated_at = now() WHERE id = $1', v_table_name)\n  USING p_order_id;\n  \n  INSERT INTO public.stage_events (order_id, store, stage, event, performed_by, notes)\n  VALUES (p_order_id, p_store, 'Covering', 'completed', v_user_id, p_notes);\n  \n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "complete_decorating",
      "function_definition": "CREATE OR REPLACE FUNCTION public.complete_decorating(p_order_id uuid)\n RETURNS orders\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_before public.stage;\n  v_after  public.stage;\n  v_row    public.orders;\nbegin\n  perform public._order_lock(p_order_id);\n\n  select stage into v_before from public.orders where id = p_order_id for update;\n  if not found then raise exception 'ORDER_NOT_FOUND'; end if;\n\n  update public.orders\n     set decorating_complete_ts = coalesce(decorating_complete_ts, now()),\n         stage = case when v_before = 'Decorating_in_progress' then 'Packing_in_progress' else stage end,\n         updated_at = now()\n   where id = p_order_id\n  returning * into v_row;\n\n  v_after := v_row.stage;\n  if v_after is distinct from v_before then\n    insert into public.stage_events(order_id, from_stage, to_stage, performed_by, reason)\n    values (p_order_id, v_before, v_after, null, 'complete_decorating');\n  end if;\n\n  insert into public.audit_log(action, performed_by, source, meta)\n  values ('complete_decorating', null, 'rpc', jsonb_build_object('order_id', p_order_id));\n\n  return v_row;\nend\n$function$\n"
    },
    {
      "function_name": "complete_decorating",
      "function_definition": "CREATE OR REPLACE FUNCTION public.complete_decorating(p_order_id text, p_store text, p_notes text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_table_name text;\n  v_user_id uuid;\nBEGIN\n  v_table_name := 'orders_' || p_store;\n  v_user_id := COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::uuid);\n  \n  EXECUTE format('UPDATE public.%I SET stage = ''Packing'', decorating_complete_ts = now(), packing_start_ts = now(), updated_at = now() WHERE id = $1', v_table_name)\n  USING p_order_id;\n  \n  INSERT INTO public.stage_events (order_id, store, stage, event, performed_by, notes)\n  VALUES (p_order_id, p_store, 'Decorating', 'completed', v_user_id, p_notes);\n  \n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "complete_filling",
      "function_definition": "CREATE OR REPLACE FUNCTION public.complete_filling(p_order_id uuid)\n RETURNS orders\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_before public.stage;\n  v_after  public.stage;\n  v_row    public.orders;\nbegin\n  perform public._order_lock(p_order_id);\n\n  select stage into v_before from public.orders where id = p_order_id for update;\n  if not found then raise exception 'ORDER_NOT_FOUND'; end if;\n\n  update public.orders\n     set filling_complete_ts = coalesce(filling_complete_ts, now()),\n         stage = case when v_before = 'Filling_in_progress' then 'Covering_pending' else stage end,\n         updated_at = now()\n   where id = p_order_id\n  returning * into v_row;\n\n  v_after := v_row.stage;\n  if v_after is distinct from v_before then\n    insert into public.stage_events(order_id, from_stage, to_stage, performed_by, reason)\n    values (p_order_id, v_before, v_after, null, 'complete_filling');\n  end if;\n\n  insert into public.audit_log(action, performed_by, source, meta)\n  values ('complete_filling', null, 'rpc', jsonb_build_object('order_id', p_order_id));\n\n  return v_row;\nend\n$function$\n"
    },
    {
      "function_name": "complete_filling",
      "function_definition": "CREATE OR REPLACE FUNCTION public.complete_filling(p_order_id text, p_store text, p_notes text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_table_name text;\n  v_current_stage stage_type;\n  v_user_id uuid;\nBEGIN\n  v_table_name := 'orders_' || p_store;\n  v_user_id := COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::uuid);\n  \n  EXECUTE format('SELECT stage FROM public.%I WHERE id = $1', v_table_name)\n  INTO v_current_stage\n  USING p_order_id;\n  \n  IF v_current_stage IS NULL THEN\n    RAISE EXCEPTION 'Order not found: %', p_order_id;\n  END IF;\n  \n  IF v_current_stage != 'Filling' THEN\n    RAISE EXCEPTION 'Order must be in Filling stage to complete filling';\n  END IF;\n  \n  EXECUTE format('UPDATE public.%I SET stage = ''Covering'', filling_complete_ts = now(), updated_at = now() WHERE id = $1', v_table_name)\n  USING p_order_id;\n  \n  INSERT INTO public.stage_events (order_id, store, stage, event, performed_by, notes)\n  VALUES (p_order_id, p_store, 'Filling', 'completed', v_user_id, p_notes);\n  \n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "complete_packing",
      "function_definition": "CREATE OR REPLACE FUNCTION public.complete_packing(p_order_id uuid)\n RETURNS orders\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_before public.stage;\n  v_row    public.orders;\nbegin\n  perform public._order_lock(p_order_id);\n\n  select stage into v_before from public.orders where id = p_order_id for update;\n  if not found then raise exception 'ORDER_NOT_FOUND'; end if;\n\n  update public.orders\n     set packing_complete_ts = coalesce(packing_complete_ts, now()),\n         stage = 'Complete',\n         updated_at = now()\n   where id = p_order_id\n  returning * into v_row;\n\n  if v_before is distinct from 'Complete' then\n    insert into public.stage_events(order_id, from_stage, to_stage, performed_by, reason)\n    values (p_order_id, v_before, 'Complete', null, 'complete_packing');\n  end if;\n\n  insert into public.audit_log(action, performed_by, source, meta)\n  values ('complete_packing', null, 'rpc', jsonb_build_object('order_id', p_order_id));\n\n  return v_row;\nend\n$function$\n"
    },
    {
      "function_name": "complete_packing",
      "function_definition": "CREATE OR REPLACE FUNCTION public.complete_packing(p_order_id text, p_store text, p_notes text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_table_name text;\n  v_user_id uuid;\nBEGIN\n  v_table_name := 'orders_' || p_store;\n  v_user_id := COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::uuid);\n  \n  EXECUTE format('UPDATE public.%I SET stage = ''Complete'', packing_complete_ts = now(), updated_at = now() WHERE id = $1', v_table_name)\n  USING p_order_id;\n  \n  INSERT INTO public.stage_events (order_id, store, stage, event, performed_by, notes)\n  VALUES (p_order_id, p_store, 'Packing', 'completed', v_user_id, p_notes);\n  \n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "create_conversation",
      "function_definition": "CREATE OR REPLACE FUNCTION public.create_conversation(p_participants uuid[], p_name text DEFAULT NULL::text, p_type text DEFAULT 'direct'::text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\ndeclare\n  v_convo_id uuid;\n  v_me uuid := auth.uid();\n  v_name text := p_name;\nbegin\n  if v_me is null then\n    raise exception 'Not authenticated';\n  end if;\n\n  if p_type not in ('direct','group','broadcast') then\n    raise exception 'Invalid conversation type %', p_type;\n  end if;\n\n  if array_length(p_participants,1) is null or array_length(p_participants,1) = 0 then\n    raise exception 'At least one participant required';\n  end if;\n\n  -- for direct, normalize name empty (UI can show other user's name)\n  if p_type = 'direct' and v_name is null then\n    v_name := null;\n  end if;\n\n  insert into public.conversations(type, name, created_by)\n  values (p_type, v_name, v_me)\n  returning id into v_convo_id;\n\n  -- add creator\n  insert into public.conversation_participants(conversation_id, user_id, role)\n  values (v_convo_id, v_me, 'owner')\n  on conflict do nothing;\n\n  -- add other participants\n  insert into public.conversation_participants(conversation_id, user_id)\n  select v_convo_id, unnest(p_participants)\n  on conflict do nothing;\n\n  -- initialize read marker for creator\n  insert into public.message_reads(conversation_id, user_id, last_read_at)\n  values (v_convo_id, v_me, now())\n  on conflict (conversation_id, user_id) do update set last_read_at = excluded.last_read_at;\n\n  return v_convo_id;\nend;\n$function$\n"
    },
    {
      "function_name": "create_conversation_text",
      "function_definition": "CREATE OR REPLACE FUNCTION public.create_conversation_text(p_participants text[], p_name text DEFAULT NULL::text, p_type text DEFAULT 'direct'::text)\n RETURNS uuid\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n  select public.create_conversation(\n    array(select x::uuid from unnest(p_participants) as x),\n    p_name,\n    p_type\n  );\n$function$\n"
    },
    {
      "function_name": "current_user_name",
      "function_definition": "CREATE OR REPLACE FUNCTION public.current_user_name()\n RETURNS text\n LANGUAGE sql\n STABLE\nAS $function$\n  select coalesce(\n    (auth.jwt() -> 'user_metadata' ->> 'full_name'),\n    (auth.jwt() ->> 'email'),\n    'Unknown'\n  );\n$function$\n"
    },
    {
      "function_name": "deduct_inventory_for_order",
      "function_definition": "CREATE OR REPLACE FUNCTION public.deduct_inventory_for_order(p_order_id text, p_product_title text, p_store text, p_quantity integer DEFAULT 1)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_user_id uuid;\n  v_bom_id uuid;\n  v_deducted_count integer := 0;\n  v_item record;\n  v_insufficient_stock text[];\nBEGIN\n  v_user_id := COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::uuid);\n  \n  -- Find matching BOM\n  SELECT id INTO v_bom_id\n  FROM public.boms\n  WHERE product_title = p_product_title\n    AND (store = p_store OR store = 'both')\n    AND is_active = true\n  LIMIT 1;\n  \n  IF v_bom_id IS NULL THEN\n    RETURN jsonb_build_object(\n      'success', false,\n      'error', 'No BOM found for product: ' || p_product_title\n    );\n  END IF;\n  \n  -- Check if we have enough stock for all components\n  FOR v_item IN\n    SELECT bi.component_id, bi.quantity_required, c.name, c.current_stock, bi.is_optional\n    FROM public.bom_items bi\n    JOIN public.components c ON bi.component_id = c.id\n    WHERE bi.bom_id = v_bom_id\n  LOOP\n    IF NOT v_item.is_optional AND v_item.current_stock < (v_item.quantity_required * p_quantity) THEN\n      v_insufficient_stock := array_append(v_insufficient_stock, v_item.name);\n    END IF;\n  END LOOP;\n  \n  -- If insufficient stock, return error\n  IF array_length(v_insufficient_stock, 1) > 0 THEN\n    RETURN jsonb_build_object(\n      'success', false,\n      'error', 'Insufficient stock',\n      'components', v_insufficient_stock\n    );\n  END IF;\n  \n  -- Deduct stock for each component\n  FOR v_item IN\n    SELECT bi.component_id, bi.quantity_required, c.current_stock\n    FROM public.bom_items bi\n    JOIN public.components c ON bi.component_id = c.id\n    WHERE bi.bom_id = v_bom_id\n      AND bi.is_optional = false\n  LOOP\n    -- Update stock\n    UPDATE public.components\n    SET current_stock = current_stock - (v_item.quantity_required * p_quantity),\n        updated_at = now()\n    WHERE id = v_item.component_id;\n    \n    -- Log transaction\n    INSERT INTO public.stock_transactions (\n      component_id, transaction_type, quantity_change,\n      quantity_before, quantity_after, reference_order_id,\n      reason, performed_by\n    )\n    VALUES (\n      v_item.component_id,\n      'order_deduction',\n      -(v_item.quantity_required * p_quantity),\n      v_item.current_stock,\n      v_item.current_stock - (v_item.quantity_required * p_quantity),\n      p_order_id,\n      'Deducted for order completion',\n      v_user_id\n    );\n    \n    v_deducted_count := v_deducted_count + 1;\n  END LOOP;\n  \n  RETURN jsonb_build_object(\n    'success', true,\n    'order_id', p_order_id,\n    'components_deducted', v_deducted_count\n  );\nEND;\n$function$\n"
    },
    {
      "function_name": "delete_accessory_keyword",
      "function_definition": "CREATE OR REPLACE FUNCTION public.delete_accessory_keyword(p_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  DELETE FROM public.accessory_keywords WHERE id = p_id;\n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "feature_rls_enabled",
      "function_definition": "CREATE OR REPLACE FUNCTION public.feature_rls_enabled()\n RETURNS boolean\n LANGUAGE sql\n STABLE\nAS $function$\nselect coalesce(\n  (select (value->>'enabled')::boolean from settings where store = 'global' and key = 'rls' limit 1),\n  false\n);\n$function$\n"
    },
    {
      "function_name": "find_component_by_keyword",
      "function_definition": "CREATE OR REPLACE FUNCTION public.find_component_by_keyword(p_keyword text)\n RETURNS TABLE(component_id uuid, component_name text, component_sku text, current_stock numeric, keyword_matched text, match_type text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    c.id as component_id,\n    c.name as component_name,\n    c.sku as component_sku,\n    c.current_stock,\n    ak.keyword as keyword_matched,\n    ak.match_type\n  FROM public.accessory_keywords ak\n  JOIN public.components c ON ak.component_id = c.id\n  WHERE ak.is_active = true\n    AND c.is_active = true\n    AND (\n      (ak.match_type = 'exact' AND LOWER(ak.keyword) = LOWER(p_keyword)) OR\n      (ak.match_type = 'contains' AND LOWER(p_keyword) LIKE '%' || LOWER(ak.keyword) || '%') OR\n      (ak.match_type = 'starts_with' AND LOWER(p_keyword) LIKE LOWER(ak.keyword) || '%')\n    )\n  ORDER BY ak.priority DESC, LENGTH(ak.keyword) DESC\n  LIMIT 1;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_accessory_keywords",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_accessory_keywords(p_search text DEFAULT NULL::text, p_is_active boolean DEFAULT true)\n RETURNS TABLE(id uuid, keyword text, component_id uuid, component_name text, component_sku text, priority integer, match_type text, is_active boolean, created_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    ak.id,\n    ak.keyword,\n    ak.component_id,\n    c.name as component_name,\n    c.sku as component_sku,\n    ak.priority,\n    ak.match_type,\n    ak.is_active,\n    ak.created_at\n  FROM public.accessory_keywords ak\n  JOIN public.components c ON ak.component_id = c.id\n  WHERE (p_is_active IS NULL OR ak.is_active = p_is_active)\n    AND (p_search IS NULL OR \n         ak.keyword ILIKE '%' || p_search || '%' OR \n         c.name ILIKE '%' || p_search || '%')\n  ORDER BY ak.priority DESC, ak.keyword;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_bom_details",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_bom_details(p_bom_id uuid)\n RETURNS TABLE(bom_id uuid, product_title text, store text, description text, component_id uuid, component_sku text, component_name text, quantity_required numeric, unit text, current_stock numeric, is_optional boolean, notes text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    b.id as bom_id,\n    b.product_title,\n    b.store,\n    b.description,\n    c.id as component_id,\n    c.sku as component_sku,\n    c.name as component_name,\n    bi.quantity_required,\n    bi.unit,\n    c.current_stock,\n    bi.is_optional,\n    bi.notes\n  FROM public.boms b\n  LEFT JOIN public.bom_items bi ON b.id = bi.bom_id\n  LEFT JOIN public.components c ON bi.component_id = c.id\n  WHERE b.id = p_bom_id\n  ORDER BY bi.is_optional, c.name;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_boms",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_boms(p_store text DEFAULT NULL::text, p_is_active boolean DEFAULT true, p_search text DEFAULT NULL::text)\n RETURNS TABLE(id uuid, product_title text, store text, description text, shopify_product_id text, is_active boolean, component_count bigint, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    b.id,\n    b.product_title,\n    b.store,\n    b.description,\n    b.shopify_product_id,\n    b.is_active,\n    COUNT(bi.id)::bigint as component_count,\n    b.created_at,\n    b.updated_at\n  FROM public.boms b\n  LEFT JOIN public.bom_items bi ON b.id = bi.bom_id\n  WHERE (p_store IS NULL OR b.store = p_store)\n    AND (p_is_active IS NULL OR b.is_active = p_is_active)\n    AND (p_search IS NULL OR b.product_title ILIKE '%' || p_search || '%')\n  GROUP BY b.id, b.product_title, b.store, b.description, b.shopify_product_id, b.is_active, b.created_at, b.updated_at\n  ORDER BY b.product_title;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_complete_minimal",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_complete_minimal(p_store text DEFAULT NULL::text, p_limit integer DEFAULT 50)\n RETURNS SETOF vw_complete_minimal\n LANGUAGE sql\n STABLE SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n  select *\n  from vw_complete_minimal\n  where (p_store is null or store = p_store)\n  order by packing_complete_ts desc nulls last\n  limit p_limit;\n$function$\n"
    },
    {
      "function_name": "get_components",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_components()\n RETURNS TABLE(id uuid, sku text, name text, description text, category text, unit text, current_stock numeric, min_stock numeric, max_stock numeric, cost_per_unit numeric, supplier text, supplier_sku text, is_active boolean, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    c.id, c.sku, c.name, c.description, c.category, c.unit,\n    c.current_stock, c.min_stock, c.max_stock, c.cost_per_unit,\n    c.supplier, c.supplier_sku, c.is_active, c.created_at, c.updated_at\n  FROM public.components c\n  WHERE c.is_active = true\n  ORDER BY c.name;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_components",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_components(p_category text DEFAULT NULL::text, p_is_active boolean DEFAULT true, p_low_stock_only boolean DEFAULT false, p_search text DEFAULT NULL::text, p_limit integer DEFAULT 100)\n RETURNS TABLE(id uuid, sku text, name text, description text, category text, unit text, current_stock numeric, min_stock numeric, max_stock numeric, cost_per_unit numeric, supplier text, supplier_sku text, is_active boolean, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    c.id, c.sku, c.name, c.description, c.category, c.unit,\n    c.current_stock, c.min_stock, c.max_stock, c.cost_per_unit,\n    c.supplier, c.supplier_sku, c.is_active, c.created_at, c.updated_at\n  FROM public.components c\n  WHERE (p_category IS NULL OR c.category = p_category)\n    AND (p_is_active IS NULL OR c.is_active = p_is_active)\n    AND (p_low_stock_only = false OR c.current_stock < c.min_stock)\n    AND (p_search IS NULL OR \n         c.name ILIKE '%' || p_search || '%' OR \n         c.sku ILIKE '%' || p_search || '%')\n  ORDER BY c.name\n  LIMIT p_limit;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_conversation_participants",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_conversation_participants(p_conversation_id uuid)\n RETURNS TABLE(user_id uuid, full_name text, role text, is_online boolean, joined_at timestamp with time zone)\n LANGUAGE sql\n STABLE SECURITY DEFINER\nAS $function$\n  select\n    cp.user_id,\n    coalesce( (auth.jwt() -> 'user_metadata' ->> 'full_name') , '' )::text as full_name, -- placeholder; wire to your staff table if needed\n    cp.role,\n    false as is_online, -- placeholder; wire to presence later\n    cp.joined_at\n  from public.conversation_participants cp\n  where cp.conversation_id = p_conversation_id\n    and exists (select 1 from public.conversation_participants p\n                where p.conversation_id = p_conversation_id and p.user_id = auth.uid());\n$function$\n"
    },
    {
      "function_name": "get_conversations",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_conversations(p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)\n RETURNS TABLE(id uuid, name text, type text, created_by uuid, created_at timestamp with time zone, last_message_text text, last_message_at timestamp with time zone, last_message_sender_id uuid, last_message_sender_name text, unread_count integer, participant_count integer)\n LANGUAGE sql\n STABLE SECURITY DEFINER\nAS $function$\nwith mine as (\n  select c.*\n  from public.conversations c\n  join public.conversation_participants p on p.conversation_id = c.id\n  where p.user_id = auth.uid()\n),\nlasts as (\n  select distinct on (m.conversation_id)\n    m.conversation_id, m.body, m.created_at, m.sender_id, m.sender_name\n  from public.messages m\n  order by m.conversation_id, m.created_at desc\n),\ncounts as (\n  select conversation_id, count(*) as participant_count\n  from public.conversation_participants\n  group by conversation_id\n),\nunread as (\n  select mc.id as conversation_id,\n         case\n           when lm.created_at is null then 0\n           when r.last_read_at is null then 1\n           when lm.created_at > r.last_read_at then 1\n           else 0\n         end as u\n  from mine mc\n  left join lasts lm on lm.conversation_id = mc.id\n  left join public.message_reads r on r.conversation_id = mc.id and r.user_id = auth.uid()\n)\nselect\n  mc.id, mc.name, mc.type, mc.created_by, mc.created_at,\n  lm.body as last_message_text,\n  lm.created_at as last_message_at,\n  lm.sender_id as last_message_sender_id,\n  lm.sender_name as last_message_sender_name,\n  coalesce(sum(u.u) over (partition by mc.id),0) as unread_count,\n  coalesce(ct.participant_count, 0) as participant_count\nfrom mine mc\nleft join lasts lm on lm.conversation_id = mc.id\nleft join counts ct on ct.conversation_id = mc.id\nleft join unread u on u.conversation_id = mc.id\norder by coalesce(lm.created_at, mc.created_at) desc\nlimit p_limit offset p_offset;\n$function$\n"
    },
    {
      "function_name": "get_due_date_settings",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_due_date_settings(p_store text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_default_due text;\n  v_allowed_days jsonb;\n  v_blackout_dates jsonb;\n  v_result jsonb;\nBEGIN\n  -- Validate store\n  IF p_store NOT IN ('bannos', 'flourlane', 'global') THEN\n    RAISE EXCEPTION 'Invalid store: %', p_store;\n  END IF;\n\n  -- Get default due date\n  SELECT value INTO v_default_due\n  FROM settings \n  WHERE store = p_store AND key = 'dueDates.defaultDue'\n  LIMIT 1;\n\n  -- Get allowed days\n  SELECT value INTO v_allowed_days\n  FROM settings \n  WHERE store = p_store AND key = 'dueDates.allowedDays'\n  LIMIT 1;\n\n  -- Get blackout dates\n  SELECT value INTO v_blackout_dates\n  FROM settings \n  WHERE store = p_store AND key = 'dueDates.blackoutDates'\n  LIMIT 1;\n\n  -- Build result object with defaults\n  v_result := jsonb_build_object(\n    'defaultDue', COALESCE(v_default_due, '+1 day'),\n    'allowedDays', COALESCE(v_allowed_days, '[true, true, true, true, true, true, false]'::jsonb),\n    'blackoutDates', COALESCE(v_blackout_dates, '[\"2024-12-25\", \"2024-01-01\"]'::jsonb)\n  );\n\n  RETURN v_result;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_flavours",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_flavours(p_store text)\n RETURNS text[]\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_flavours text[];\nBEGIN\n  -- Validate store\n  IF p_store NOT IN ('bannos', 'flourlane', 'global') THEN\n    RAISE EXCEPTION 'Invalid store: %', p_store;\n  END IF;\n\n  -- Get flavours from settings table\n  SELECT COALESCE(\n    (SELECT ARRAY(\n      SELECT jsonb_array_elements_text(value)\n      FROM settings \n      WHERE store = p_store AND key = 'flavours'\n      -- REMOVED LIMIT 1 - this was causing only the first flavour to be returned\n    )),\n    CASE \n      WHEN p_store = 'bannos' THEN ARRAY['Vanilla', 'Chocolate', 'Strawberry', 'Red Velvet', 'Lemon', 'Coffee']\n      WHEN p_store = 'flourlane' THEN ARRAY['Vanilla', 'Chocolate', 'Strawberry', 'Red Velvet', 'Lemon', 'Coffee', 'Matcha', 'Salted Caramel']\n      ELSE ARRAY['Vanilla', 'Chocolate', 'Strawberry']\n    END\n  ) INTO v_flavours;\n\n  RETURN v_flavours;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_low_stock_components",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_low_stock_components()\n RETURNS TABLE(id uuid, sku text, name text, current_stock numeric, min_stock numeric, stock_deficit numeric)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    c.id,\n    c.sku,\n    c.name,\n    c.current_stock,\n    c.min_stock,\n    (c.min_stock - c.current_stock) as stock_deficit\n  FROM public.components c\n  WHERE c.is_active = true \n    AND c.current_stock < c.min_stock\n  ORDER BY (c.min_stock - c.current_stock) DESC;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_messages",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_messages(p_conversation_id uuid, p_limit integer DEFAULT 50)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_user_id UUID;\n  v_messages JSONB;\nBEGIN\n  -- Get current user ID\n  v_user_id := auth.uid();\n  \n  -- Validate user is authenticated\n  IF v_user_id IS NULL THEN\n    RETURN jsonb_build_object(\n      'success', false,\n      'message', 'User not authenticated',\n      'data', null,\n      'error_code', 'AUTH_REQUIRED'\n    );\n  END IF;\n  \n  -- Validate user is participant in conversation\n  IF NOT EXISTS (\n    SELECT 1 FROM public.conversation_participants \n    WHERE conversation_id = p_conversation_id \n    AND participant_id = v_user_id\n  ) THEN\n    RETURN jsonb_build_object(\n      'success', false,\n      'message', 'User not participant in conversation',\n      'data', null,\n      'error_code', 'NOT_PARTICIPANT'\n    );\n  END IF;\n  \n  -- Get messages with sender info\n  SELECT jsonb_agg(\n    jsonb_build_object(\n      'id', m.id,\n      'content', m.content,\n      'sender_id', m.sender_id,\n      'sender_name', s.full_name,\n      'created_at', m.created_at,\n      'read_by', m.read_by\n    ) ORDER BY m.created_at DESC\n  )\n  INTO v_messages\n  FROM public.messages m\n  JOIN public.staff_shared s ON s.user_id = m.sender_id\n  WHERE m.conversation_id = p_conversation_id\n  LIMIT p_limit;\n  \n  RETURN jsonb_build_object(\n    'success', true,\n    'message', 'Messages retrieved successfully',\n    'data', COALESCE(v_messages, '[]'::jsonb),\n    'error_code', null\n  );\nEND;\n$function$\n"
    },
    {
      "function_name": "get_messages_debug",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_messages_debug(p_conversation_id uuid)\n RETURNS TABLE(debug_info text, user_id uuid, is_participant boolean, message_count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_user_id UUID;\n  v_is_participant BOOLEAN;\n  v_message_count BIGINT;\nBEGIN\n  v_user_id := auth.uid();\n  \n  v_is_participant := EXISTS (\n    SELECT 1 FROM public.conversation_participants \n    WHERE conversation_id = p_conversation_id \n    AND participant_id = v_user_id\n  );\n  \n  v_message_count := (\n    SELECT COUNT(*) FROM public.messages \n    WHERE conversation_id = p_conversation_id\n  );\n  \n  RETURN QUERY\n  SELECT \n    'Debug info'::text as debug_info,\n    v_user_id,\n    v_is_participant,\n    v_message_count;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_messages_temp",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_messages_temp(p_conversation_id uuid, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)\n RETURNS TABLE(id bigint, body text, sender_id uuid, sender_name text, created_at timestamp with time zone, is_own_message boolean)\n LANGUAGE sql\n STABLE SECURITY DEFINER\nAS $function$\n  select\n    m.id, m.body, m.sender_id, m.sender_name, m.created_at,\n    (m.sender_id = auth.uid()) as is_own_message\n  from public.messages m\n  where m.conversation_id = p_conversation_id\n    and exists (select 1 from public.conversation_participants p\n                where p.conversation_id = m.conversation_id\n                  and p.user_id = auth.uid())\n  order by m.created_at asc\n  limit p_limit offset p_offset\n$function$\n"
    },
    {
      "function_name": "get_messages_temp_test",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_messages_temp_test(p_conversation_id uuid, p_limit integer DEFAULT 50, p_offset integer DEFAULT 0)\n RETURNS TABLE(id uuid, body text, sender_id uuid, sender_name text, created_at timestamp with time zone, is_own_message boolean)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Return messages WITHOUT authentication check for testing\n  RETURN QUERY\n  SELECT \n    m.id,\n    m.content as body,\n    m.sender_id,\n    s.full_name as sender_name,\n    m.created_at,\n    false as is_own_message  -- Set to false for testing\n  FROM public.messages m\n  JOIN public.staff_shared s ON s.user_id = m.sender_id\n  WHERE m.conversation_id = p_conversation_id\n  ORDER BY m.created_at DESC\n  LIMIT p_limit\n  OFFSET p_offset;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_monitor_density",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_monitor_density(p_store text)\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_density text;\nBEGIN\n  -- Validate store\n  IF p_store NOT IN ('bannos', 'flourlane', 'global') THEN\n    RAISE EXCEPTION 'Invalid store: %', p_store;\n  END IF;\n\n  -- Get monitor density from settings table\n  SELECT COALESCE(\n    (SELECT value#>>'{}'  -- Extract raw string from JSONB\n     FROM settings \n     WHERE store = p_store AND key = 'monitor.density'\n     LIMIT 1),\n    'cozy' -- Default value\n  ) INTO v_density;\n\n  RETURN v_density;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_order_for_scan",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_order_for_scan(p_code text)\n RETURNS orders\n LANGUAGE plpgsql\n STABLE SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  s text := lower(trim(p_code));\n  v_store text;\n  v_num bigint;\n  v_id uuid;\n  v_row public.orders;\nbegin\n  -- UUID direct\n  if s ~ '^[0-9a-f-]{36}$' then\n    begin v_id := s::uuid; exception when others then v_id := null; end;\n    if v_id is not null then\n      select * into v_row from public.orders where id = v_id limit 1;\n      return v_row;\n    end if;\n  end if;\n\n  -- Exact barcode match\n  select * into v_row from public.orders where barcode = p_code limit 1;\n  if found then return v_row; end if;\n\n  -- bannos-##### / flourlane-##### / plain number\n  if s like 'bannos-%' then\n    v_store := 'bannos';\n    begin v_num := substring(s from 'bannos-(\\d+)')::bigint; exception when others then v_num := null; end;\n  elsif s like 'flourlane-%' then\n    v_store := 'flourlane';\n    begin v_num := substring(s from 'flourlane-(\\d+)')::bigint; exception when others then v_num := null; end;\n  elsif s ~ '^\\d+$' then\n    v_num := s::bigint;\n  end if;\n\n  -- store + number\n  if v_store is not null and v_num is not null then\n    select * into v_row from public.orders where store = v_store and shopify_order_number = v_num limit 1;\n    if found then return v_row; end if;\n  end if;\n\n  -- number only across stores\n  if v_num is not null then\n    select * into v_row from public.orders where shopify_order_number = v_num limit 1;\n    if found then return v_row; end if;\n  end if;\n\n  return v_row; -- null if no match\nend\n$function$\n"
    },
    {
      "function_name": "get_printing_settings",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_printing_settings(p_store text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Return default printing settings\n  RETURN jsonb_build_object(\n    'printer_name', 'Default Printer',\n    'paper_size', 'A4',\n    'orientation', 'portrait',\n    'auto_print', true,\n    'print_barcodes', true,\n    'print_labels', true\n  );\nEND;\n$function$\n"
    },
    {
      "function_name": "get_product_requirements",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_product_requirements(p_shopify_product_id text DEFAULT NULL::text, p_search text DEFAULT NULL::text)\n RETURNS TABLE(id uuid, shopify_product_id text, shopify_variant_id text, product_title text, component_id uuid, component_name text, component_sku text, quantity_per_unit numeric, current_stock numeric, is_optional boolean, auto_deduct boolean, created_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    pr.id,\n    pr.shopify_product_id,\n    pr.shopify_variant_id,\n    pr.product_title,\n    c.id as component_id,\n    c.name as component_name,\n    c.sku as component_sku,\n    pr.quantity_per_unit,\n    c.current_stock,\n    pr.is_optional,\n    pr.auto_deduct,\n    pr.created_at\n  FROM public.product_requirements pr\n  JOIN public.components c ON pr.component_id = c.id\n  WHERE (p_shopify_product_id IS NULL OR pr.shopify_product_id = p_shopify_product_id)\n    AND (p_search IS NULL OR \n         pr.product_title ILIKE '%' || p_search || '%' OR \n         c.name ILIKE '%' || p_search || '%')\n  ORDER BY pr.product_title, c.name;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_queue",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_queue(p_store text DEFAULT NULL::text, p_stage text DEFAULT NULL::text, p_assignee_id uuid DEFAULT NULL::uuid, p_search text DEFAULT NULL::text, p_priority text DEFAULT NULL::text, p_storage text DEFAULT NULL::text, p_offset integer DEFAULT 0, p_limit integer DEFAULT 50, p_sort_by text DEFAULT 'priority'::text, p_sort_order text DEFAULT 'DESC'::text)\n RETURNS TABLE(id text, shopify_order_id bigint, shopify_order_number integer, customer_name text, product_title text, flavour text, notes text, currency character, total_amount numeric, stage stage_type, priority priority_level, due_date date, delivery_method text, size text, item_qty integer, storage text, assignee_id uuid, assignee_name text, store text, created_at timestamp with time zone, updated_at timestamp with time zone, total_count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  IF p_store = 'bannos' OR p_store IS NULL THEN\n    RETURN QUERY\n    SELECT \n      o.id,\n      o.shopify_order_id,\n      o.shopify_order_number,\n      o.customer_name,\n      o.product_title,\n      o.flavour,\n      o.notes,\n      o.currency,\n      o.total_amount,\n      o.stage,\n      o.priority,\n      o.due_date,\n      o.delivery_method,\n      o.size,\n      o.item_qty,\n      o.storage,\n      o.assignee_id,\n      s.full_name as assignee_name,\n      'bannos'::text as store,\n      o.created_at,\n      o.updated_at,\n      COUNT(*) OVER() as total_count\n    FROM public.orders_bannos o\n    LEFT JOIN public.staff_shared s ON o.assignee_id = s.user_id\n    WHERE (p_stage IS NULL OR o.stage::text = p_stage)\n      AND (p_assignee_id IS NULL OR o.assignee_id = p_assignee_id)\n      AND (p_priority IS NULL OR o.priority::text = p_priority)\n      AND (p_storage IS NULL OR o.storage = p_storage)\n      AND (p_search IS NULL OR \n           o.customer_name ILIKE '%' || p_search || '%' OR \n           o.product_title ILIKE '%' || p_search || '%' OR\n           o.id ILIKE '%' || p_search || '%')\n    ORDER BY \n      CASE WHEN p_sort_by = 'priority' AND p_sort_order = 'DESC' THEN o.priority END DESC,\n      CASE WHEN p_sort_by = 'priority' AND p_sort_order = 'ASC' THEN o.priority END ASC,\n      CASE WHEN p_sort_by = 'due_date' AND p_sort_order = 'DESC' THEN o.due_date END DESC,\n      CASE WHEN p_sort_by = 'due_date' AND p_sort_order = 'ASC' THEN o.due_date END ASC,\n      o.created_at ASC\n    LIMIT p_limit OFFSET p_offset;\n  END IF;\n\n  IF p_store = 'flourlane' OR p_store IS NULL THEN\n    RETURN QUERY\n    SELECT \n      o.id,\n      o.shopify_order_id,\n      o.shopify_order_number,\n      o.customer_name,\n      o.product_title,\n      o.flavour,\n      o.notes,\n      o.currency,\n      o.total_amount,\n      o.stage,\n      o.priority,\n      o.due_date,\n      o.delivery_method,\n      o.size,\n      o.item_qty,\n      o.storage,\n      o.assignee_id,\n      s.full_name as assignee_name,\n      'flourlane'::text as store,\n      o.created_at,\n      o.updated_at,\n      COUNT(*) OVER() as total_count\n    FROM public.orders_flourlane o\n    LEFT JOIN public.staff_shared s ON o.assignee_id = s.user_id\n    WHERE (p_stage IS NULL OR o.stage::text = p_stage)\n      AND (p_assignee_id IS NULL OR o.assignee_id = p_assignee_id)\n      AND (p_priority IS NULL OR o.priority::text = p_priority)\n      AND (p_storage IS NULL OR o.storage = p_storage)\n      AND (p_search IS NULL OR \n           o.customer_name ILIKE '%' || p_search || '%' OR \n           o.product_title ILIKE '%' || p_search || '%' OR\n           o.id ILIKE '%' || p_search || '%')\n    ORDER BY \n      CASE WHEN p_sort_by = 'priority' AND p_sort_order = 'DESC' THEN o.priority END DESC,\n      CASE WHEN p_sort_by = 'priority' AND p_sort_order = 'ASC' THEN o.priority END ASC,\n      CASE WHEN p_sort_by = 'due_date' AND p_sort_order = 'DESC' THEN o.due_date END DESC,\n      CASE WHEN p_sort_by = 'due_date' AND p_sort_order = 'ASC' THEN o.due_date END ASC,\n      o.created_at ASC\n    LIMIT p_limit OFFSET p_offset;\n  END IF;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_queue_minimal",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_queue_minimal(p_store text DEFAULT NULL::text, p_limit integer DEFAULT 100, p_offset integer DEFAULT 0)\n RETURNS SETOF vw_queue_minimal\n LANGUAGE sql\n STABLE SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\n  select *\n  from vw_queue_minimal\n  where (p_store is null or store = p_store)\n  order by due_date asc nulls last, created_at asc\n  limit p_limit offset p_offset;\n$function$\n"
    },
    {
      "function_name": "get_queue_stats",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_queue_stats(p_store text)\n RETURNS TABLE(total_orders bigint, completed_orders bigint, in_production bigint, unassigned_orders bigint, filling_count bigint, covering_count bigint, decorating_count bigint, packing_count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_table_name text;\nBEGIN\n  v_table_name := 'orders_' || p_store;\n  \n  RETURN QUERY EXECUTE format('\n    SELECT \n      COUNT(*)::bigint as total_orders,\n      COUNT(*) FILTER (WHERE stage = ''Complete'')::bigint as completed_orders,\n      COUNT(*) FILTER (WHERE stage != ''Complete'')::bigint as in_production,\n      COUNT(*) FILTER (WHERE assignee_id IS NULL AND stage != ''Complete'')::bigint as unassigned_orders,\n      COUNT(*) FILTER (WHERE stage = ''Filling'')::bigint as filling_count,\n      COUNT(*) FILTER (WHERE stage = ''Covering'')::bigint as covering_count,\n      COUNT(*) FILTER (WHERE stage = ''Decorating'')::bigint as decorating_count,\n      COUNT(*) FILTER (WHERE stage = ''Packing'')::bigint as packing_count\n    FROM public.%I\n  ', v_table_name);\nEND;\n$function$\n"
    },
    {
      "function_name": "get_setting",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_setting(p_store text, p_key text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_value jsonb;\nBEGIN\n  -- Validate store\n  IF p_store NOT IN ('bannos', 'flourlane', 'global') THEN\n    RAISE EXCEPTION 'Invalid store: %', p_store;\n  END IF;\n\n  -- Get setting value\n  SELECT value INTO v_value\n  FROM public.settings\n  WHERE store = p_store AND key = p_key\n  LIMIT 1;\n\n  RETURN v_value;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_settings",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_settings(p_store text)\n RETURNS TABLE(store text, key text, value jsonb, created_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Validate store\n  IF p_store NOT IN ('bannos', 'flourlane', 'global') THEN\n    RAISE EXCEPTION 'Invalid store: %', p_store;\n  END IF;\n\n  RETURN QUERY\n  SELECT \n    s.store,\n    s.key,\n    s.value,\n    s.created_at\n  FROM public.settings s\n  WHERE s.store = p_store\n  ORDER BY s.key;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_staff",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_staff()\n RETURNS TABLE(user_id uuid, full_name text, role text)\n LANGUAGE sql\n STABLE SECURITY DEFINER\nAS $function$\n  select s.user_id, s.full_name, s.role\n  from public.staff_shared s\n  order by s.full_name;\n$function$\n"
    },
    {
      "function_name": "get_staff_list",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_staff_list(p_role text DEFAULT NULL::text, p_is_active boolean DEFAULT true)\n RETURNS TABLE(user_id uuid, full_name text, email text, role text, store text, is_active boolean, phone text, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    s.user_id,\n    s.full_name,\n    s.email,\n    s.role,\n    s.store,\n    s.is_active,\n    s.phone,\n    s.created_at,\n    s.updated_at\n  FROM public.staff_shared s\n  WHERE (p_role IS NULL OR s.role = p_role)\n    AND (p_is_active IS NULL OR s.is_active = p_is_active)\n  ORDER BY s.full_name;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_staff_me",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_staff_me()\n RETURNS TABLE(user_id uuid, full_name text, role text, store text, is_active boolean, phone text, email text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  IF auth.uid() IS NULL THEN\n    RAISE EXCEPTION 'Not authenticated';\n  END IF;\n\n  RETURN QUERY\n  SELECT \n    s.user_id,\n    s.full_name,\n    s.role,\n    s.store,\n    s.is_active,\n    s.phone,\n    s.email\n  FROM public.staff_shared s\n  WHERE s.user_id = auth.uid();\nEND;\n$function$\n"
    },
    {
      "function_name": "get_staff_member",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_staff_member(p_user_id uuid)\n RETURNS TABLE(user_id uuid, full_name text, role text, store text, is_active boolean, phone text, email text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Check if user_id is provided\n  IF p_user_id IS NULL THEN\n    RAISE EXCEPTION 'User ID is required';\n  END IF;\n\n  -- Return staff member data\n  RETURN QUERY\n  SELECT\n    s.user_id,\n    s.full_name,\n    s.role,\n    s.store,\n    s.is_active,\n    s.phone,\n    s.email\n  FROM public.staff_shared s\n  WHERE s.user_id = p_user_id\n    AND s.is_active = true;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_staff_stats",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_staff_stats()\n RETURNS TABLE(user_id uuid, assigned_orders bigint)\n LANGUAGE sql\n STABLE SECURITY DEFINER\nAS $function$\n  with all_orders as (\n    select assignee_id from public.orders_bannos\n    union all\n    select assignee_id from public.orders_flourlane\n  )\n  select s.user_id,\n         count(a.assignee_id)::bigint as assigned_orders\n  from public.staff_shared s\n  left join all_orders a on a.assignee_id = s.user_id\n  group by s.user_id\n  order by assigned_orders desc nulls last;\n$function$\n"
    },
    {
      "function_name": "get_stock_transactions",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_stock_transactions(p_component_id uuid DEFAULT NULL::uuid, p_order_id text DEFAULT NULL::text, p_transaction_type text DEFAULT NULL::text, p_limit integer DEFAULT 100)\n RETURNS TABLE(id uuid, component_id uuid, component_name text, component_sku text, transaction_type text, quantity_change numeric, quantity_before numeric, quantity_after numeric, reference_order_id text, reason text, performed_by uuid, performer_name text, created_at timestamp with time zone)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    st.id,\n    st.component_id,\n    c.name as component_name,\n    c.sku as component_sku,\n    st.transaction_type,\n    st.quantity_change,\n    st.quantity_before,\n    st.quantity_after,\n    st.reference_order_id,\n    st.reason,\n    st.performed_by,\n    s.full_name as performer_name,\n    st.created_at\n  FROM public.stock_transactions st\n  JOIN public.components c ON st.component_id = c.id\n  LEFT JOIN public.staff_shared s ON st.performed_by = s.user_id\n  WHERE (p_component_id IS NULL OR st.component_id = p_component_id)\n    AND (p_order_id IS NULL OR st.reference_order_id = p_order_id)\n    AND (p_transaction_type IS NULL OR st.transaction_type = p_transaction_type)\n  ORDER BY st.created_at DESC\n  LIMIT p_limit;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_storage_locations",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_storage_locations(p_store text)\n RETURNS text[]\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_locations text[];\nBEGIN\n  -- Validate store\n  IF p_store NOT IN ('bannos', 'flourlane', 'global') THEN\n    RAISE EXCEPTION 'Invalid store: %', p_store;\n  END IF;\n\n  -- Get storage locations from settings table\n  SELECT COALESCE(\n    (SELECT ARRAY(\n      SELECT jsonb_array_elements_text(value)\n      FROM settings \n      WHERE store = p_store AND key = 'storage_locations'\n      -- Removed LIMIT 1 here\n    )),\n    CASE \n      WHEN p_store = 'bannos' THEN ARRAY['Store Fridge', 'Store Freezer', 'Kitchen Coolroom', 'Kitchen Freezer', 'Basement Coolroom']\n      WHEN p_store = 'flourlane' THEN ARRAY['Store Fridge', 'Store Freezer', 'Kitchen Coolroom', 'Kitchen Freezer', 'Basement Coolroom', 'Display Case']\n      ELSE ARRAY['General Storage', 'Cold Storage', 'Freezer Storage']\n    END\n  ) INTO v_locations;\n\n  RETURN v_locations;\nEND;\n$function$\n"
    },
    {
      "function_name": "get_unassigned_counts",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_unassigned_counts(p_store text)\n RETURNS TABLE(stage text, count bigint)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_table_name text;\nBEGIN\n  v_table_name := 'orders_' || p_store;\n  \n  RETURN QUERY EXECUTE format('\n    SELECT \n      stage::text,\n      COUNT(*)::bigint\n    FROM public.%I\n    WHERE assignee_id IS NULL AND stage != ''Complete''\n    GROUP BY stage\n    ORDER BY stage\n  ', v_table_name);\nEND;\n$function$\n"
    },
    {
      "function_name": "get_unread_count",
      "function_definition": "CREATE OR REPLACE FUNCTION public.get_unread_count()\n RETURNS integer\n LANGUAGE sql\n STABLE SECURITY DEFINER\nAS $function$\nwith my_convos as (\n  select c.id\n  from public.conversations c\n  join public.conversation_participants p on p.conversation_id = c.id\n  where p.user_id = auth.uid()\n),\nlast_msg as (\n  select conversation_id, max(created_at) as last_msg_at\n  from public.messages\n  group by conversation_id\n)\nselect coalesce(count(*),0)\nfrom my_convos mc\nleft join last_msg lm on lm.conversation_id = mc.id\nleft join public.message_reads r on r.conversation_id = mc.id and r.user_id = auth.uid()\nwhere lm.last_msg_at is not null\n  and (r.last_read_at is null or lm.last_msg_at > r.last_read_at);\n$function$\n"
    },
    {
      "function_name": "handle_print_barcode",
      "function_definition": "CREATE OR REPLACE FUNCTION public.handle_print_barcode(p_order_id uuid, p_barcode text)\n RETURNS orders\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_before public.stage;\n  v_after  public.stage;\n  v_row    public.orders;\nbegin\n  perform public._order_lock(p_order_id);\n\n  select stage into v_before from public.orders where id = p_order_id for update;\n  if not found then raise exception 'ORDER_NOT_FOUND'; end if;\n\n  if exists (select 1 from public.orders where id = p_order_id and barcode is not null and barcode <> p_barcode)\n  then raise exception 'BARCODE_MISMATCH'; end if;\n\n  update public.orders\n     set barcode = coalesce(barcode, p_barcode),\n         filling_start_ts = coalesce(filling_start_ts, now()),\n         stage = case when stage = 'Filling_pending' then 'Filling_in_progress' else stage end,\n         updated_at = now()\n   where id = p_order_id\n  returning * into v_row;\n\n  v_after := v_row.stage;\n  if v_after is distinct from v_before then\n    insert into public.stage_events(order_id, from_stage, to_stage, performed_by, reason)\n    values (p_order_id, v_before, v_after, null, 'print_barcode');\n  end if;\n\n  insert into public.audit_log(action, performed_by, source, meta)\n  values ('handle_print_barcode', null, 'rpc', jsonb_build_object('order_id', p_order_id, 'barcode', p_barcode));\n\n  return v_row;\nend\n$function$\n"
    },
    {
      "function_name": "ingest_order",
      "function_definition": "CREATE OR REPLACE FUNCTION public.ingest_order(payload jsonb DEFAULT NULL::jsonb, normalized jsonb DEFAULT NULL::jsonb)\n RETURNS void\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\ndeclare\n  v_enabled boolean := public.settings_get_bool('global','ingest', false);\n  v_in      jsonb    := coalesce(payload, normalized);  -- < accept either key\n\n  v_shop_domain text := coalesce(v_in->>'shop_domain', v_in->>'domain', v_in->'shop'->>'domain');\n  v_store       text;\n\n  v_gid             text := v_in->>'admin_graphql_api_id';\n  v_shopify_id      text := v_in->>'id';\n  v_order_number    text := coalesce(v_in->>'order_number', v_in->>'name');\n\n  v_customer_name   text := coalesce(\n                          v_in->'shipping_address'->>'name',\n                          v_in->'customer'->>'name',\n                          trim(concat_ws(' ', v_in->'customer'->>'first_name', v_in->'customer'->>'last_name'))\n                        );\n  v_notes           text := coalesce(v_in->>'note','');\n  v_delivery_instr  text;\n\n  v_method_raw      text;\n  v_delivery_method text;\n  v_due_raw         text;\n  v_due_text        text;\n  v_delivery_date   date;\n\n  v_currency        text := coalesce(v_in->>'presentment_currency', v_in->>'currency');\n  v_total_amount    numeric(12,2) := coalesce(nullif(v_in->>'current_total_price','')::numeric,\n                                             nullif(v_in->>'total_price','')::numeric, 0);\n\n  v_line            jsonb;\n  v_product_title   text;\n  v_item_qty        integer;\n  v_flavour         text;\nbegin\n  if not v_enabled then return; end if;\n\n  v_store := case\n    when v_shop_domain ilike '%bannos%'    then 'bannos'\n    when v_shop_domain ilike '%flourlane%' then 'flourlane'\n    else null\n  end;\n  if v_store is null then\n    raise exception 'Unknown shop domain: %', coalesce(v_shop_domain, '<null>');\n  end if;\n\n  if v_gid is null then\n    raise exception 'Missing admin_graphql_api_id';\n  end if;\n\n  -- primary line item: first non-gift with qty > 0\n  select li\n  into v_line\n  from jsonb_array_elements(coalesce(v_in->'line_items','[]'::jsonb)) li\n  where coalesce((li->>'gift_card')::boolean, false) = false\n    and coalesce((li->>'quantity')::int, 0) > 0\n  limit 1;\n\n  v_product_title := coalesce(v_line->>'title','');\n  v_item_qty      := nullif(v_line->>'quantity','')::int;\n\n  -- flavour: \"gelato flavour(s)\" (skip internal keys)  variant_title fallback\n  with props as (\n    select p\n    from jsonb_array_elements(coalesce(v_line->'properties','[]'::jsonb)) p\n  ),\n  visible as (\n    select p\n    from props\n    where not (\n      coalesce(lower(p->>'name'), lower(p->>'first'), '') like '\\_%' escape '\\'\n      or coalesce(lower(p->>'name'), lower(p->>'first'), '') ~ '_origin|_raw|gwp|_LocalDeliveryID'\n    )\n  ),\n  hit as (\n    select p\n    from visible\n    where coalesce(p->>'name', p->>'first') ~* 'gelato flavour(s)?'\n       or lower(coalesce(p->>'name', p->>'first')) in ('flavour','flavor')\n    limit 1\n  )\n  select string_agg(trim(x), ', ') into v_flavour\n  from (\n    select unnest(regexp_split_to_array(coalesce((select h.p->>'value' from hit h), ''), E'\\\\r?\\\\n|,|/')) x\n  ) s\n  where x <> '';\n\n  if coalesce(v_flavour,'') = '' then\n    v_flavour := coalesce(split_part(coalesce(v_line->>'variant_title',''), ',', 1), '');\n    if position('/' in v_flavour) > 0 then\n      v_flavour := split_part(v_flavour, '/', 1);\n    end if;\n  end if;\n\n  -- delivery method (attributes first)\n  select na->>'value' into v_method_raw\n  from jsonb_path_query(v_in, '$.note_attributes[*] ? (@.name != null)') as na\n  where lower(na->>'name') in ('delivery method','pickup or delivery')\n  limit 1;\n  if v_method_raw is not null then\n    v_delivery_method := case when lower(v_method_raw) ~ 'pickup|pick up' then 'pickup' else 'delivery' end;\n  end if;\n\n  -- delivery date (strip between  then parse)\n  select na->>'value' into v_due_raw\n  from jsonb_path_query(v_in, '$.note_attributes[*] ? (@.name != null)') as na\n  where lower(na->>'name') in ('local delivery date and time','delivery date','pickup date')\n  limit 1;\n  if v_due_raw is not null then\n    v_due_text := split_part(v_due_raw, 'between', 1);\n    begin\n      v_delivery_date := v_due_text::date;\n    exception when others then\n      begin\n        v_delivery_date := to_date(regexp_replace(v_due_text, '.*?(\\d{4}-\\d{2}-\\d{2}).*', '\\1'), 'YYYY-MM-DD');\n      exception when others then\n        v_delivery_date := null;\n      end;\n    end;\n  end if;\n\n  -- notes aggregation: order note + Delivery Instructions\n  select na->>'value' into v_delivery_instr\n  from jsonb_path_query(v_in, '$.note_attributes[*] ? (@.name != null)') as na\n  where lower(na->>'name') = 'delivery instructions'\n  limit 1;\n  if coalesce(v_delivery_instr,'') <> '' then\n    v_notes := trim(both ' ' from concat_ws('  ', nullif(v_notes,''), v_delivery_instr));\n  end if;\n\n  -- INSERT (human_id is filled by trigger)\n  insert into public.orders (\n    store, shopify_order_id, shopify_order_gid, order_number,\n    customer_name, delivery_date, delivery_method, product_title, flavour,\n    item_qty, notes, currency, total_amount, order_json\n  )\n  values (\n    v_store, v_shopify_id, v_gid, v_order_number,\n    v_customer_name, v_delivery_date, v_delivery_method, v_product_title, v_flavour,\n    v_item_qty, v_notes, v_currency, v_total_amount, v_in\n  )\n  on conflict (shopify_order_gid) do nothing;\nend\n$function$\n"
    },
    {
      "function_name": "ingest_order",
      "function_definition": "CREATE OR REPLACE FUNCTION public.ingest_order(p_shop_domain text, payload jsonb DEFAULT NULL::jsonb, normalized jsonb DEFAULT NULL::jsonb)\n RETURNS void\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n  select public.ingest_order(\n    coalesce(payload, normalized) || jsonb_build_object('shop_domain', p_shop_domain),\n    null\n  );\n$function$\n"
    },
    {
      "function_name": "is_cake_item",
      "function_definition": "CREATE OR REPLACE FUNCTION public.is_cake_item(p_item jsonb)\n RETURNS boolean\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n  select coalesce( (p_item->>'product_type') ilike '%cake%'\n                or (p_item->>'title') ilike '%cake%', false )\n$function$\n"
    },
    {
      "function_name": "mark_messages_read",
      "function_definition": "CREATE OR REPLACE FUNCTION public.mark_messages_read(p_conversation_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\ndeclare v_me uuid := auth.uid();\nbegin\n  if v_me is null then raise exception 'Not authenticated'; end if;\n\n  insert into public.message_reads(conversation_id, user_id, last_read_at)\n  values (p_conversation_id, v_me, now())\n  on conflict (conversation_id, user_id) do update set last_read_at = excluded.last_read_at;\n\n  return true;\nend;\n$function$\n"
    },
    {
      "function_name": "move_to_filling_with_assignment",
      "function_definition": "CREATE OR REPLACE FUNCTION public.move_to_filling_with_assignment(p_order_id uuid, p_staff_id uuid)\n RETURNS orders\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_before public.stage;\n  v_after  public.stage;\n  v_row    public.orders;\nbegin\n  perform public._order_lock(p_order_id);\n\n  select stage into v_before from public.orders where id = p_order_id for update;\n  if not found then raise exception 'ORDER_NOT_FOUND'; end if;\n\n  update public.orders\n     set assignee_id = p_staff_id,\n         stage = case when stage in ('Filling_pending','Filling_in_progress') then 'Filling_in_progress' else stage end,\n         updated_at = now()\n   where id = p_order_id\n  returning * into v_row;\n\n  v_after := v_row.stage;\n  if v_after is distinct from v_before then\n    insert into public.stage_events(order_id, from_stage, to_stage, performed_by, reason)\n    values (p_order_id, v_before, v_after, null, 'assign_to_filling');\n  end if;\n\n  insert into public.audit_log(action, performed_by, source, meta)\n  values ('move_to_filling_with_assignment', null, 'rpc', jsonb_build_object('order_id', p_order_id, 'staff_id', p_staff_id));\n\n  return v_row;\nend\n$function$\n"
    },
    {
      "function_name": "orders_set_human_id",
      "function_definition": "CREATE OR REPLACE FUNCTION public.orders_set_human_id()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nbegin\n  new.human_id := new.store::text || '-' ||\n                  coalesce(\n                    nullif(new.order_number::text, ''),\n                    nullif(new.shopify_order_number::text, ''),\n                    new.shopify_order_id::text\n                  );\n  return new;\nend\n$function$\n"
    },
    {
      "function_name": "process_kitchen_task_create",
      "function_definition": "CREATE OR REPLACE FUNCTION public.process_kitchen_task_create(p_limit integer DEFAULT 20, p_lock_secs integer DEFAULT 60)\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_now timestamptz := now();\n  v_count int := 0;\n  v_job record;\n  v_p jsonb;\n  v_shop text;\n  v_order uuid;   -- set per job, deterministically\n  v_suffix text;\nbegin\n  -- Validate inputs (defensive)\n  if p_limit < 1 or p_limit > 100 then\n    raise exception 'p_limit must be between 1 and 100';\n  end if;\n  if p_lock_secs < 1 or p_lock_secs > 3600 then\n    raise exception 'p_lock_secs must be between 1 and 3600';\n  end if;\n\n  for v_job in\n    select *\n      from public.work_queue\n     where status = 'pending'\n       and topic  = 'kitchen_task_create'\n       and (locked_at is null or locked_at < v_now - make_interval(secs => p_lock_secs))\n     order by created_at asc\n     limit p_limit\n     for update skip locked\n  loop\n    begin\n      update public.work_queue\n         set locked_at = v_now, locked_by = 'stage-ticket-worker', status='processing'\n       where id = v_job.id;\n\n      v_p    := v_job.payload;\n      v_shop := v_p->>'shop_domain';\n      if v_shop is null then\n        raise exception 'missing payload: shop_domain';\n      end if;\n\n      -- Deterministic order UUID: use parent webhook id (Shopify header) we stored in worker #1.\n      -- All A/B/C tasks from the same order share this UUID; retries reuse it exactly.\n      v_order := nullif(v_p->>'parent_hook_id','')::uuid;\n      if v_order is null then\n        -- fallback (rare): stable per job id\n        v_order := v_job.id; -- requires work_queue.id to be uuid (it is in your DB)\n      end if;\n\n      -- Extract and validate suffix (A/B/C)\n      v_suffix := nullif(v_p->>'task_suffix','');\n      if v_suffix is null then\n        raise exception 'missing payload: task_suffix';\n      end if;\n      if v_suffix !~ '^[A-Z]+$' then\n        raise exception 'invalid task_suffix: %', v_suffix;\n      end if;\n\n      insert into public.stage_events(order_id, shop_domain, stage, status, task_suffix)\n      values (v_order, v_shop, 'Filling', 'pending', v_suffix)\n      on conflict (order_id, shop_domain, stage, task_suffix) do nothing;\n\n      update public.work_queue set status='done', updated_at=now() where id=v_job.id;\n      v_count := v_count + 1;\n\n    exception when others then\n      insert into public.dead_letter(created_at, payload, reason)\n      values (\n        now(),\n        jsonb_build_object('worker','process_kitchen_task_create','job_id',v_job.id,'error',SQLERRM),\n        'stage_ticket_failed'\n      );\n      update public.work_queue set status='error', updated_at=now() where id=v_job.id;\n    end;\n  end loop;\n\n  return v_count;\nend;\n$function$\n"
    },
    {
      "function_name": "process_webhook_order_split",
      "function_definition": "CREATE OR REPLACE FUNCTION public.process_webhook_order_split(p_limit integer DEFAULT 10, p_lock_secs integer DEFAULT 60)\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_now timestamptz := now();\n  v_count int := 0;\n  v_job record;\n  v_payload jsonb;\n  v_items jsonb;\n  v_cakes jsonb := '[]'::jsonb;\n  v_accessories jsonb := '[]'::jsonb;\n  v_shop text;\n  v_topic text;\n  v_hook text;\n  v_body jsonb;\n  i int := 0;\n  v_suffix text;\nbegin\n  -- lock a batch of jobs\n  for v_job in\n    select *\n    from public.work_queue\n    where status = 'pending'\n      and topic = 'webhook_order_split'\n      and (locked_at is null or locked_at < v_now - make_interval(secs => p_lock_secs))\n    order by created_at asc\n    limit p_limit\n    for update skip locked\n  loop\n    begin\n      -- lock\n      update public.work_queue\n         set locked_at = v_now,\n             locked_by = 'order-split-worker',\n             status = 'processing'\n       where id = v_job.id;\n\n      v_payload := v_job.payload;\n      v_shop    := (v_payload->>'shop_domain');\n      v_topic   := (v_payload->>'topic');\n      v_hook    := (v_payload->>'hook_id');\n      v_body    := (v_payload->'body');\n\n      -- Validate required fields\n      if v_shop is null or v_topic is null or v_hook is null or v_body is null then\n        raise exception 'Missing required payload fields (shop_domain/topic/hook_id/body)';\n      end if;\n\n      -- Expect Shopify order payload with line_items array\n      v_items := coalesce(v_body->'line_items', '[]'::jsonb);\n\n      -- Separate cakes vs accessories\n      v_cakes := '[]'::jsonb;\n      v_accessories := '[]'::jsonb;\n      for i in 0 .. coalesce(jsonb_array_length(v_items), 0)-1 loop\n        if public.is_cake_item(v_items->i) then\n          -- push N times by quantity\n          for _q in 1 .. coalesce(((v_items->i)->>'quantity')::int, 1) loop\n            v_cakes := v_cakes || jsonb_build_array(v_items->i);\n          end loop;\n        else\n          v_accessories := v_accessories || jsonb_build_array(v_items->i);\n        end if;\n      end loop;\n\n      if jsonb_array_length(v_cakes) = 0 then\n        update public.work_queue set status = 'done', updated_at = now() where id = v_job.id;\n        v_count := v_count + 1;\n        continue;\n      end if;\n\n      -- Emit one child job per cake with A/B/C; accessories only on A\n      for i in 0 .. coalesce(jsonb_array_length(v_cakes), 0)-1 loop\n        v_suffix := public.alpha_suffix(i);\n        insert into public.work_queue (topic, payload, status)\n        values (\n          'kitchen_task_create',\n          jsonb_build_object(\n            'shop_domain', v_shop,\n            'parent_hook_id', v_hook,\n            'parent_topic', v_topic,\n            'order_id', coalesce(v_body->>'id', v_body->>'order_number'),\n            'task_suffix', v_suffix,\n            'line_item', v_cakes->i,\n            'accessories', case when i = 0 then v_accessories else '[]'::jsonb end\n          ),\n          'pending'\n        );\n      end loop;\n\n      -- complete parent\n      update public.work_queue\n         set status = 'done',\n             updated_at = now()\n       where id = v_job.id;\n\n      v_count := v_count + 1;\n\n    exception when others then\n      -- mark error and keep evidence\n      insert into public.dead_letter (created_at, payload, reason)\n      values (now(),\n              jsonb_build_object(\n                'worker', 'process_webhook_order_split',\n                'error', SQLERRM,\n                'job_id', v_job.id,\n                'hook_id', v_hook,\n                'shop_domain', v_shop\n              ),\n              'split_worker_failed');\n\n      update public.work_queue\n         set status = 'error',\n             updated_at = now()\n       where id = v_job.id;\n    end;\n  end loop;\n\n  return v_count;\nend;\n$function$\n"
    },
    {
      "function_name": "qc_return_to_decorating",
      "function_definition": "CREATE OR REPLACE FUNCTION public.qc_return_to_decorating(p_order_id uuid, p_reason text)\n RETURNS orders\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_before public.stage;\n  v_row    public.orders;\nbegin\n  perform public._order_lock(p_order_id);\n\n  select stage into v_before from public.orders where id = p_order_id for update;\n  if not found then raise exception 'ORDER_NOT_FOUND'; end if;\n\n  update public.orders\n     set stage = 'Decorating_pending',\n         updated_at = now()\n   where id = p_order_id\n     and v_before = 'Packing_in_progress'\n  returning * into v_row;\n\n  if not found then\n    select * into v_row from public.orders where id = p_order_id;\n    return v_row;\n  end if;\n\n  insert into public.stage_events(order_id, from_stage, to_stage, performed_by, reason)\n  values (p_order_id, v_before, 'Decorating_pending', null, coalesce(p_reason,'qc_return'));\n\n  insert into public.audit_log(action, performed_by, source, meta)\n  values ('qc_return_to_decorating', null, 'rpc', jsonb_build_object('order_id', p_order_id, 'reason', p_reason));\n\n  return v_row;\nend\n$function$\n"
    },
    {
      "function_name": "record_component_txn",
      "function_definition": "CREATE OR REPLACE FUNCTION public.record_component_txn(p_component_id uuid, p_qty_delta numeric, p_reason text, p_ref text DEFAULT NULL::text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\ndeclare\n  v_txn_id uuid;\n  v_onhand numeric;\nbegin\n  -- Optional safety: prevent negative stock\n  select coalesce(sum(qty_delta),0) into v_onhand\n  from public.component_txns\n  where component_id = p_component_id;\n\n  if v_onhand + p_qty_delta < 0 then\n    raise exception 'Insufficient stock for component % (onhand %, delta %)', p_component_id, v_onhand, p_qty_delta;\n  end if;\n\n  insert into public.component_txns (component_id, qty_delta, reason, ref)\n  values (p_component_id, p_qty_delta, p_reason, p_ref)\n  returning id into v_txn_id;\n\n  return v_txn_id;\nend $function$\n"
    },
    {
      "function_name": "remove_bom_component",
      "function_definition": "CREATE OR REPLACE FUNCTION public.remove_bom_component(p_bom_id uuid, p_component_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  DELETE FROM public.bom_items\n  WHERE bom_id = p_bom_id AND component_id = p_component_id;\n  \n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "remove_participant",
      "function_definition": "CREATE OR REPLACE FUNCTION public.remove_participant(p_conversation_id uuid, p_user_id uuid)\n RETURNS boolean\n LANGUAGE sql\n SECURITY DEFINER\nAS $function$\n  delete from public.conversation_participants\n  where conversation_id = p_conversation_id and user_id = p_user_id;\n  select true;\n$function$\n"
    },
    {
      "function_name": "remove_participant",
      "function_definition": "CREATE OR REPLACE FUNCTION public.remove_participant(p_conversation_id text, p_user_id text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  DELETE FROM public.conversation_participants\n  WHERE conversation_id = p_conversation_id::uuid\n    AND user_id = p_user_id::uuid;\n  \n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "restock_order",
      "function_definition": "CREATE OR REPLACE FUNCTION public.restock_order(p_order_id text, p_store text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_user_id uuid;\n  v_restocked_count integer := 0;\n  v_transaction record;\nBEGIN\n  v_user_id := COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::uuid);\n  \n  -- Find all deductions for this order and reverse them\n  FOR v_transaction IN \n    SELECT component_id, ABS(quantity_change) as qty_to_restore\n    FROM public.stock_transactions\n    WHERE reference_order_id = p_order_id\n      AND transaction_type = 'order_deduction'\n  LOOP\n    -- Add the stock back\n    UPDATE public.components\n    SET current_stock = current_stock + v_transaction.qty_to_restore,\n        updated_at = now()\n    WHERE id = v_transaction.component_id;\n    \n    -- Log the restock transaction\n    INSERT INTO public.stock_transactions (\n      component_id, transaction_type, quantity_change,\n      quantity_before, quantity_after, reference_order_id,\n      reason, performed_by\n    )\n    SELECT \n      v_transaction.component_id,\n      'order_restock',\n      v_transaction.qty_to_restore,\n      current_stock - v_transaction.qty_to_restore,\n      current_stock,\n      p_order_id,\n      'Order cancelled/returned - restocking components',\n      v_user_id\n    FROM public.components\n    WHERE id = v_transaction.component_id;\n    \n    v_restocked_count := v_restocked_count + 1;\n  END LOOP;\n  \n  RETURN jsonb_build_object(\n    'success', true,\n    'order_id', p_order_id,\n    'components_restocked', v_restocked_count\n  );\nEND;\n$function$\n"
    },
    {
      "function_name": "rls_bypass",
      "function_definition": "CREATE OR REPLACE FUNCTION public.rls_bypass()\n RETURNS boolean\n LANGUAGE sql\n STABLE\nAS $function$\nselect (not feature_rls_enabled()) or app_is_service_role();\n$function$\n"
    },
    {
      "function_name": "send_message",
      "function_definition": "CREATE OR REPLACE FUNCTION public.send_message(p_conversation_id uuid, p_content text)\n RETURNS bigint\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\ndeclare\n  v_me uuid := auth.uid();\n  v_id bigint;\n  v_name text := public.current_user_name();\nbegin\n  if v_me is null then\n    raise exception 'Not authenticated';\n  end if;\n  if p_content is null or length(btrim(p_content)) = 0 then\n    raise exception 'Message body required';\n  end if;\n\n  -- only participants can post\n  if not exists (\n    select 1 from public.conversation_participants p\n    where p.conversation_id = p_conversation_id and p.user_id = v_me\n  ) then\n    raise exception 'Not a participant';\n  end if;\n\n  insert into public.messages(conversation_id, sender_id, sender_name, body)\n  values (p_conversation_id, v_me, coalesce(v_name, 'Unknown'), p_content)\n  returning id into v_id;\n\n  -- mark the sender as read now\n  insert into public.message_reads(conversation_id, user_id, last_read_at)\n  values (p_conversation_id, v_me, now())\n  on conflict (conversation_id, user_id) do update set last_read_at = excluded.last_read_at;\n\n  return v_id;\nend;\n$function$\n"
    },
    {
      "function_name": "set_due_date_settings",
      "function_definition": "CREATE OR REPLACE FUNCTION public.set_due_date_settings(p_store text, p_settings jsonb)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_default_due text;\n  v_allowed_days jsonb;\n  v_blackout_dates jsonb;\nBEGIN\n  -- Validate store\n  IF p_store NOT IN ('bannos', 'flourlane', 'global') THEN\n    RAISE EXCEPTION 'Invalid store: %', p_store;\n  END IF;\n\n  -- Validate settings object\n  IF p_settings IS NULL THEN\n    RAISE EXCEPTION 'Settings object cannot be null';\n  END IF;\n\n  -- Extract values from settings object\n  v_default_due := p_settings->>'defaultDue';\n  v_allowed_days := p_settings->'allowedDays';\n  v_blackout_dates := p_settings->'blackoutDates';\n\n  -- Validate required fields\n  IF v_default_due IS NULL OR v_default_due = '' THEN\n    RAISE EXCEPTION 'defaultDue is required';\n  END IF;\n\n  IF v_allowed_days IS NULL OR jsonb_typeof(v_allowed_days) != 'array' THEN\n    RAISE EXCEPTION 'allowedDays must be a JSON array';\n  END IF;\n\n  IF v_blackout_dates IS NULL OR jsonb_typeof(v_blackout_dates) != 'array' THEN\n    RAISE EXCEPTION 'blackoutDates must be a JSON array';\n  END IF;\n\n  -- Insert or update settings\n  INSERT INTO public.settings (store, key, value)\n  VALUES \n    (p_store, 'dueDates.defaultDue', to_jsonb(v_default_due)),\n    (p_store, 'dueDates.allowedDays', v_allowed_days),\n    (p_store, 'dueDates.blackoutDates', v_blackout_dates)\n  ON CONFLICT (store, key) \n  DO UPDATE SET value = EXCLUDED.value, created_at = now();\n  \n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "set_flavours",
      "function_definition": "CREATE OR REPLACE FUNCTION public.set_flavours(p_store text, p_flavours text[])\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_flavours_json jsonb;\nBEGIN\n  -- Validate store\n  IF p_store NOT IN ('bannos', 'flourlane', 'global') THEN\n    RAISE EXCEPTION 'Invalid store: %', p_store;\n  END IF;\n\n  -- Validate flavours array\n  IF p_flavours IS NULL OR array_length(p_flavours, 1) = 0 THEN\n    RAISE EXCEPTION 'Flavours array cannot be empty';\n  END IF;\n\n  -- Convert text array to JSONB array\n  v_flavours_json := to_jsonb(p_flavours);\n\n  -- Insert or update flavours in settings table\n  INSERT INTO public.settings (store, key, value)\n  VALUES (p_store, 'flavours', v_flavours_json)\n  ON CONFLICT (store, key) \n  DO UPDATE SET value = v_flavours_json, created_at = now();\n  \n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "set_monitor_density",
      "function_definition": "CREATE OR REPLACE FUNCTION public.set_monitor_density(p_store text, p_density text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Validate store\n  IF p_store NOT IN ('bannos', 'flourlane', 'global') THEN\n    RAISE EXCEPTION 'Invalid store: %', p_store;\n  END IF;\n\n  -- Validate density value\n  IF p_density NOT IN ('compact', 'cozy') THEN\n    RAISE EXCEPTION 'Invalid density value: %. Must be \"compact\" or \"cozy\"', p_density;\n  END IF;\n\n  -- Insert or update monitor density in settings table\n  INSERT INTO public.settings (store, key, value)\n  VALUES (p_store, 'monitor.density', to_jsonb(p_density))\n  ON CONFLICT (store, key) \n  DO UPDATE SET value = to_jsonb(p_density), created_at = now();\n  \n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "set_printing_settings",
      "function_definition": "CREATE OR REPLACE FUNCTION public.set_printing_settings(p_store text, p_settings jsonb)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- For now, just return success\n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "set_setting",
      "function_definition": "CREATE OR REPLACE FUNCTION public.set_setting(p_store text, p_key text, p_value jsonb)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  -- Validate store\n  IF p_store NOT IN ('bannos', 'flourlane', 'global') THEN\n    RAISE EXCEPTION 'Invalid store: %', p_store;\n  END IF;\n\n  -- Validate key\n  IF p_key IS NULL OR p_key = '' THEN\n    RAISE EXCEPTION 'Setting key cannot be empty';\n  END IF;\n\n  -- Insert or update setting\n  INSERT INTO public.settings (store, key, value)\n  VALUES (p_store, p_key, p_value)\n  ON CONFLICT (store, key) \n  DO UPDATE SET value = p_value, created_at = now();\n  \n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "set_storage_locations",
      "function_definition": "CREATE OR REPLACE FUNCTION public.set_storage_locations(p_store text, p_locations text[])\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_locations_json jsonb;\nBEGIN\n  -- Validate store\n  IF p_store NOT IN ('bannos', 'flourlane', 'global') THEN\n    RAISE EXCEPTION 'Invalid store: %', p_store;\n  END IF;\n\n  -- Validate locations array\n  IF p_locations IS NULL OR array_length(p_locations, 1) = 0 THEN\n    RAISE EXCEPTION 'Storage locations array cannot be empty';\n  END IF;\n\n  -- Convert text array to JSONB array\n  v_locations_json := to_jsonb(p_locations);\n\n  -- Insert or update storage locations in settings table\n  INSERT INTO public.settings (store, key, value)\n  VALUES (p_store, 'storage_locations', v_locations_json)\n  ON CONFLICT (store, key) \n  DO UPDATE SET value = v_locations_json, created_at = now();\n  \n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "set_updated_at",
      "function_definition": "CREATE OR REPLACE FUNCTION public.set_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  NEW.updated_at = now();\n  RETURN NEW;\nEND;\n$function$\n"
    },
    {
      "function_name": "settings_get_bool",
      "function_definition": "CREATE OR REPLACE FUNCTION public.settings_get_bool(ns text, k text, default_value boolean)\n RETURNS boolean\n LANGUAGE sql\n STABLE\nAS $function$\n  select coalesce((\n    select\n      case\n        when jsonb_typeof(s.value) = 'boolean' then (s.value)::boolean\n        when jsonb_typeof(s.value) is null then default_value\n        else\n          case\n            when lower(trim(both '\"' from (s.value)::text)) in ('1','true','yes','on') then true\n            else false\n          end\n      end\n    from public.settings s\n    where s.store = ns and s.key = k\n    limit 1\n  ), default_value);\n$function$\n"
    },
    {
      "function_name": "start_packing",
      "function_definition": "CREATE OR REPLACE FUNCTION public.start_packing(p_order_id uuid)\n RETURNS orders\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\ndeclare\n  v_row public.orders;\nbegin\n  perform public._order_lock(p_order_id);\n\n  update public.orders\n     set packing_start_ts = coalesce(packing_start_ts, now()),\n         updated_at = now()\n   where id = p_order_id\n  returning * into v_row;\n\n  insert into public.audit_log(action, performed_by, source, meta)\n  values ('start_packing', null, 'rpc', jsonb_build_object('order_id', p_order_id));\n\n  return v_row;\nend\n$function$\n"
    },
    {
      "function_name": "test_auth",
      "function_definition": "CREATE OR REPLACE FUNCTION public.test_auth()\n RETURNS TABLE(user_id uuid, user_email text)\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT \n    auth.uid() as user_id,\n    auth.email() as user_email;\nEND;\n$function$\n"
    },
    {
      "function_name": "test_rpc_call",
      "function_definition": "CREATE OR REPLACE FUNCTION public.test_rpc_call()\n RETURNS text\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nBEGIN\n  RETURN 'RPC function called successfully at ' || NOW()::text || ' by user ' || COALESCE(auth.uid()::text, 'NULL');\nEND;\n$function$\n"
    },
    {
      "function_name": "update_component_stock",
      "function_definition": "CREATE OR REPLACE FUNCTION public.update_component_stock(p_component_id uuid, p_delta numeric, p_reason text, p_order_id text DEFAULT NULL::text)\n RETURNS jsonb\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_old_stock numeric;\n  v_new_stock numeric;\n  v_user_id uuid;\n  v_component_name text;\nBEGIN\n  -- Get current user (or NULL if not authenticated)\n  v_user_id := auth.uid();\n  \n  -- Get current stock and component name\n  SELECT current_stock, name INTO v_old_stock, v_component_name\n  FROM public.components \n  WHERE id = p_component_id;\n  \n  IF v_old_stock IS NULL THEN\n    RAISE EXCEPTION 'Component not found: %', p_component_id;\n  END IF;\n  \n  -- Calculate new stock\n  v_new_stock := v_old_stock + p_delta;\n  \n  IF v_new_stock < 0 THEN\n    RAISE EXCEPTION 'Insufficient stock. Current: %, Requested: %', v_old_stock, ABS(p_delta);\n  END IF;\n  \n  -- Update component stock\n  UPDATE public.components \n  SET \n    current_stock = v_new_stock,\n    updated_at = now()\n  WHERE id = p_component_id;\n  \n  -- Log the transaction using the correct audit_log structure\n  INSERT INTO public.audit_log (\n    action,\n    performed_by,\n    source,\n    meta\n  ) VALUES (\n    'update_stock',\n    v_user_id,  -- This will be NULL if no user is authenticated\n    'inventory_system',\n    jsonb_build_object(\n      'component_id', p_component_id,\n      'component_name', v_component_name,\n      'old_stock', v_old_stock,\n      'new_stock', v_new_stock,\n      'delta', p_delta,\n      'reason', p_reason,\n      'order_id', COALESCE(p_order_id, 'N/A')\n    )\n  );\n  \n  -- Return success response\n  RETURN jsonb_build_object(\n    'success', true,\n    'component_id', p_component_id,\n    'old_stock', v_old_stock,\n    'new_stock', v_new_stock,\n    'delta', p_delta\n  );\nEND;\n$function$\n"
    },
    {
      "function_name": "update_order_core",
      "function_definition": "CREATE OR REPLACE FUNCTION public.update_order_core(p_order_id text, p_store text, p_customer_name text DEFAULT NULL::text, p_product_title text DEFAULT NULL::text, p_flavour text DEFAULT NULL::text, p_notes text DEFAULT NULL::text, p_due_date date DEFAULT NULL::date, p_delivery_method text DEFAULT NULL::text, p_size text DEFAULT NULL::text, p_item_qty integer DEFAULT NULL::integer, p_storage text DEFAULT NULL::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_table_name text;\n  v_old_values jsonb;\n  v_new_values jsonb;\n  v_user_id uuid;\n  v_update_parts text[] := ARRAY[]::text[];\n  v_new_priority smallint;\n  v_current_due_date date;\nBEGIN\n  -- Check if user has permission to update orders\n  IF NOT public.check_user_role('Supervisor') THEN\n    RAISE EXCEPTION 'Insufficient permissions to update orders';\n  END IF;\n\n  -- Validate store\n  IF p_store NOT IN ('bannos', 'flourlane') THEN\n    RAISE EXCEPTION 'Invalid store: %', p_store;\n  END IF;\n\n  -- Get user ID for audit log\n  v_user_id := COALESCE(auth.uid(), '00000000-0000-0000-0000-000000000000'::uuid);\n\n  -- Set table name based on store\n  v_table_name := 'orders_' || p_store;\n\n  -- Get current values for audit log and due_date\n  EXECUTE format('SELECT to_jsonb(o.*), o.due_date FROM public.%I o WHERE o.id = $1', v_table_name)\n  USING p_order_id INTO v_old_values, v_current_due_date;\n\n  IF v_old_values IS NULL THEN\n    RAISE EXCEPTION 'Order not found: %', p_order_id;\n  END IF;\n\n  -- Calculate new priority if due_date is being updated\n  IF p_due_date IS NOT NULL THEN\n    -- Priority calculation based on due_date (same logic as order_transform.ts)\n    -- HIGH: today/overdue/tomorrow (deltaDays <= 1)\n    -- MEDIUM: within 3 days (deltaDays <= 3)  \n    -- LOW: more than 3 days (deltaDays > 3)\n    DECLARE\n      v_delta_days integer;\n    BEGIN\n      v_delta_days := p_due_date - CURRENT_DATE;\n      \n      IF v_delta_days <= 1 THEN\n        v_new_priority := 1; -- HIGH\n      ELSIF v_delta_days <= 3 THEN\n        v_new_priority := 0; -- MEDIUM\n      ELSE\n        v_new_priority := -1; -- LOW\n      END IF;\n    END;\n  END IF;\n\n  -- Build dynamic UPDATE statement\n  IF p_customer_name IS NOT NULL THEN\n    v_update_parts := array_append(v_update_parts, 'customer_name = ' || quote_literal(p_customer_name));\n  END IF;\n\n  IF p_product_title IS NOT NULL THEN\n    v_update_parts := array_append(v_update_parts, 'product_title = ' || quote_literal(p_product_title));\n  END IF;\n\n  IF p_flavour IS NOT NULL THEN\n    v_update_parts := array_append(v_update_parts, 'flavour = ' || quote_literal(p_flavour));\n  END IF;\n\n  IF p_notes IS NOT NULL THEN\n    v_update_parts := array_append(v_update_parts, 'notes = ' || quote_literal(p_notes));\n  END IF;\n\n  IF p_due_date IS NOT NULL THEN\n    v_update_parts := array_append(v_update_parts, 'due_date = ' || quote_literal(p_due_date));\n    -- Update priority when due_date changes\n    v_update_parts := array_append(v_update_parts, 'priority = ' || v_new_priority);\n  END IF;\n\n  IF p_delivery_method IS NOT NULL THEN\n    v_update_parts := array_append(v_update_parts, 'delivery_method = ' || quote_literal(p_delivery_method));\n  END IF;\n\n  IF p_size IS NOT NULL THEN\n    v_update_parts := array_append(v_update_parts, 'size = ' || quote_literal(p_size));\n  END IF;\n\n  IF p_item_qty IS NOT NULL THEN\n    v_update_parts := array_append(v_update_parts, 'item_qty = ' || p_item_qty);\n  END IF;\n\n  IF p_storage IS NOT NULL THEN\n    v_update_parts := array_append(v_update_parts, 'storage = ' || quote_literal(p_storage));\n  END IF;\n\n  -- If nothing to update, return early\n  IF array_length(v_update_parts, 1) IS NULL THEN\n    RETURN false;\n  END IF;\n\n  -- Add updated_at\n  v_update_parts := array_append(v_update_parts, 'updated_at = now()');\n\n  -- Execute update\n  EXECUTE format('UPDATE public.%I SET %s WHERE id = $1', \n    v_table_name, array_to_string(v_update_parts, ', '))\n  USING p_order_id;\n\n  -- Get new values for audit log\n  EXECUTE format('SELECT to_jsonb(o.*) FROM public.%I o WHERE o.id = $1', v_table_name)\n  USING p_order_id INTO v_new_values;\n\n  -- Log the action\n  INSERT INTO public.audit_log (\n    table_name, record_id, action, old_values, new_values, actor_id, store, order_id\n  ) VALUES (\n    v_table_name, p_order_id, 'update_order_core',\n    v_old_values, v_new_values, v_user_id, p_store, p_order_id\n  );\n\n  RETURN true;\nEND;\n$function$\n"
    },
    {
      "function_name": "upsert_accessory_keyword",
      "function_definition": "CREATE OR REPLACE FUNCTION public.upsert_accessory_keyword(p_keyword text, p_component_id uuid, p_id uuid DEFAULT NULL::uuid, p_priority integer DEFAULT 0, p_match_type text DEFAULT 'contains'::text, p_is_active boolean DEFAULT true)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_keyword_id uuid;\nBEGIN\n  IF p_id IS NOT NULL THEN\n    -- Update existing keyword\n    UPDATE public.accessory_keywords\n    SET keyword = p_keyword,\n        component_id = p_component_id,\n        priority = p_priority,\n        match_type = p_match_type,\n        is_active = p_is_active,\n        updated_at = now()\n    WHERE id = p_id\n    RETURNING id INTO v_keyword_id;\n  ELSE\n    -- Create new keyword\n    INSERT INTO public.accessory_keywords (keyword, component_id, priority, match_type, is_active)\n    VALUES (p_keyword, p_component_id, p_priority, p_match_type, p_is_active)\n    RETURNING id INTO v_keyword_id;\n  END IF;\n  \n  RETURN v_keyword_id;\nEND;\n$function$\n"
    },
    {
      "function_name": "upsert_bom",
      "function_definition": "CREATE OR REPLACE FUNCTION public.upsert_bom(p_product_title text, p_store text, p_bom_id uuid DEFAULT NULL::uuid, p_description text DEFAULT NULL::text, p_shopify_product_id text DEFAULT NULL::text)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_bom_id uuid;\nBEGIN\n  IF p_bom_id IS NOT NULL THEN\n    -- Update existing BOM\n    UPDATE public.boms\n    SET product_title = p_product_title,\n        store = p_store,\n        description = p_description,\n        shopify_product_id = p_shopify_product_id,\n        updated_at = now()\n    WHERE id = p_bom_id\n    RETURNING id INTO v_bom_id;\n  ELSE\n    -- Create new BOM\n    INSERT INTO public.boms (product_title, store, description, shopify_product_id)\n    VALUES (p_product_title, p_store, p_description, p_shopify_product_id)\n    RETURNING id INTO v_bom_id;\n  END IF;\n  \n  RETURN v_bom_id;\nEND;\n$function$\n"
    },
    {
      "function_name": "upsert_component",
      "function_definition": "CREATE OR REPLACE FUNCTION public.upsert_component(p_sku text, p_name text, p_id uuid DEFAULT NULL::uuid, p_description text DEFAULT NULL::text, p_category text DEFAULT NULL::text, p_unit text DEFAULT 'each'::text, p_current_stock numeric DEFAULT 0, p_min_stock numeric DEFAULT 0, p_max_stock numeric DEFAULT NULL::numeric, p_cost_per_unit numeric DEFAULT NULL::numeric, p_supplier text DEFAULT NULL::text, p_supplier_sku text DEFAULT NULL::text, p_is_active boolean DEFAULT true)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_component_id uuid;\n  v_user_id uuid;\nBEGIN\n  -- Get user ID for audit log (only if user is authenticated)\n  v_user_id := auth.uid();\n\n  -- Upsert component (without is_active column since it doesn't exist in the table)\n  INSERT INTO public.components (\n    id, sku, name, description, category, unit, \n    current_stock, min_stock, max_stock, cost_per_unit, \n    supplier, supplier_sku\n  ) VALUES (\n    COALESCE(p_id, gen_random_uuid()),\n    p_sku, p_name, p_description, p_category, p_unit,\n    p_current_stock, p_min_stock, p_max_stock, p_cost_per_unit,\n    p_supplier, p_supplier_sku\n  )\n  ON CONFLICT (sku) DO UPDATE SET\n    name = EXCLUDED.name,\n    description = EXCLUDED.description,\n    category = EXCLUDED.category,\n    unit = EXCLUDED.unit,\n    current_stock = EXCLUDED.current_stock,\n    min_stock = EXCLUDED.min_stock,\n    max_stock = EXCLUDED.max_stock,\n    cost_per_unit = EXCLUDED.cost_per_unit,\n    supplier = EXCLUDED.supplier,\n    supplier_sku = EXCLUDED.supplier_sku,\n    updated_at = now()\n  RETURNING id INTO v_component_id;\n\n  -- Log the action (only if we have a valid user ID)\n  IF v_user_id IS NOT NULL THEN\n    INSERT INTO public.audit_log (\n      action,\n      performed_by,\n      source,\n      meta\n    ) VALUES (\n      CASE WHEN p_id IS NOT NULL THEN 'update_component' ELSE 'create_component' END,\n      v_user_id,\n      'inventory_system',\n      jsonb_build_object(\n        'component_id', v_component_id,\n        'sku', p_sku,\n        'name', p_name,\n        'category', p_category\n      )\n    );\n  END IF;\n\n  RETURN v_component_id;\nEND;\n$function$\n"
    },
    {
      "function_name": "upsert_product_requirement",
      "function_definition": "CREATE OR REPLACE FUNCTION public.upsert_product_requirement(p_shopify_product_id text, p_shopify_variant_id text, p_product_title text, p_component_id uuid, p_quantity_per_unit numeric, p_id uuid DEFAULT NULL::uuid, p_is_optional boolean DEFAULT false, p_auto_deduct boolean DEFAULT true)\n RETURNS uuid\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n  v_req_id uuid;\nBEGIN\n  IF p_id IS NOT NULL THEN\n    -- Update existing\n    UPDATE public.product_requirements\n    SET shopify_product_id = p_shopify_product_id,\n        shopify_variant_id = p_shopify_variant_id,\n        product_title = p_product_title,\n        component_id = p_component_id,\n        quantity_per_unit = p_quantity_per_unit,\n        is_optional = p_is_optional,\n        auto_deduct = p_auto_deduct,\n        updated_at = now()\n    WHERE id = p_id\n    RETURNING id INTO v_req_id;\n  ELSE\n    -- Create new\n    INSERT INTO public.product_requirements (\n      shopify_product_id, shopify_variant_id, product_title,\n      component_id, quantity_per_unit, is_optional, auto_deduct\n    )\n    VALUES (\n      p_shopify_product_id, p_shopify_variant_id, p_product_title,\n      p_component_id, p_quantity_per_unit, p_is_optional, p_auto_deduct\n    )\n    RETURNING id INTO v_req_id;\n  END IF;\n  \n  RETURN v_req_id;\nEND;\n$function$\n"
    }
  ]